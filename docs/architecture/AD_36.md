---
ad_number: 36
name: Vivaldi-Based Cross-Datacenter Job Routing
description: Uses Vivaldi RTT estimation with health buckets for latency-aware, safety-monotonic job routing.
---

# AD-36: Vivaldi-Based Cross-Datacenter Job Routing

**Status**: Proposed
**Related**: AD-35 (Vivaldi Coordinates), AD-33 (Federated Health Monitoring), AD-16 (Datacenter Health Classification)

---

## Problem Statement

Gates need to route jobs to the optimal datacenter while respecting safety and stability constraints:

### Current Challenges

1. **Static Routing Rules**: Manual configuration of datacenter priorities
   - Requires O(n^2) configuration for n datacenters
   - Cannot adapt to network changes (route shifts, CDN changes, degradation)
   - No learning of actual topology

2. **No Latency Awareness**: All datacenters treated equally
   - May route to distant datacenter while nearby datacenter is available
   - User jobs experience higher latency than necessary
   - Inefficient use of network capacity

3. **Binary Health Decisions**: Datacenter is either "healthy" or "unhealthy"
   - Ignores partial degradation (e.g., 80% capacity available)
   - Ignores load imbalance (one DC overloaded, another idle)
   - All-or-nothing routing decisions

4. **No Multi-Factor Optimization**: Cannot balance competing factors
   - Closest datacenter may be overloaded
   - Healthiest datacenter may be far away
   - No principled way to trade off latency vs. load vs. health

---

## Solution: Vivaldi-Based Multi-Factor Routing

AD-36 extends AD-17 by using AD-35's confidence-aware RTT estimation to rank candidates **within** health buckets.
This keeps safety monotonic while improving latency and load efficiency.

### Design Goals

1. **Monotonic safety**: Never route to a worse health bucket because it is closer
2. **Confidence-aware latency**: Use RTT UCB, not raw RTT
3. **Graceful bootstrapping**: Missing coordinates never exclude a DC
4. **Low churn**: Hysteresis prevents routing oscillations
5. **Deterministic fallback**: Clear, ordered fallback chain

---

## Part 1: Routing Inputs

**Per-datacenter inputs**:
- Health bucket: HEALTHY / BUSY / DEGRADED (AD-16)
- Capacity: available_cores, total_cores
- Load signals: queue_depth, LHM multiplier, circuit-breaker pressure
- Vivaldi: leader coordinate, error, sample_count, updated_at

**Per-manager inputs** (within a DC):
- Circuit state (OPEN/HALF/closed)
- Manager health and capacity
- Vivaldi RTT to manager

---

## Part 2: Candidate Filtering

**DC hard excludes**:
- `UNHEALTHY` status
- No registered managers
- All managers circuit-open

**DC soft demotions**:
- Stale health -> treat as DEGRADED (do not exclude)
- Missing coordinates -> keep, but apply conservative RTT defaults

**Manager hard excludes**:
- Circuit breaker OPEN
- Heartbeat stale beyond TTL

---

## Part 3: Bucket Selection (AD-17 Preserved)

```
primary_bucket = first_non_empty([HEALTHY, BUSY, DEGRADED])
```

- Only candidates in `primary_bucket` are eligible for primary selection.
- Lower buckets are **fallback only**.
- Health ordering is never violated by RTT scoring.

---

## Part 4: Authoritative Scoring Function

### Step 1: RTT UCB (from AD-35)

```
rtt_ucb_ms = estimate_rtt_ucb_ms(local_coord, dc_leader_coord)
```

### Step 2: Load Factor (monotonic, capped)

```python
util = 1.0 - clamp01(available_cores / max(total_cores, 1))
queue = queue_depth / (queue_depth + QUEUE_SMOOTHING)
cb = open_managers / max(total_managers, 1)

load_factor = 1.0 + A_UTIL * util + A_QUEUE * queue + A_CB * cb
load_factor = min(load_factor, LOAD_FACTOR_MAX)
```

### Step 3: Coordinate Quality Penalty

```python
quality = coordinate_quality(sample_count, error_ms, staleness_s)
quality_penalty = 1.0 + A_QUALITY * (1.0 - quality)
quality_penalty = min(quality_penalty, QUALITY_PENALTY_MAX)
```

### Final Score

```python
score = rtt_ucb_ms * load_factor * quality_penalty
```

**Preferred DCs** (if provided) apply a bounded multiplier **within the primary bucket only**:

```python
if dc in preferred:
    score *= PREFERENCE_MULT
```

---

## Part 5: Hysteresis and Stickiness

Routing decisions must be stable to avoid oscillation:

1. **Hold-down**: keep current primary for `HOLD_DOWN_S` unless it becomes excluded
2. **Switch threshold**: only switch if new best improves by `IMPROVEMENT_RATIO`
3. **Forced switch** if:
   - current DC drops bucket
   - current DC is excluded
   - score degrades by `DEGRADE_RATIO` for `DEGRADE_CONFIRM_S`
4. **Cooldown after failover**: add a temporary penalty to recently failed DCs

### State Diagram

```
[Selected]
   | hold-down
   |
   +-(forced switch)----------------> [Switch]
   |                                  |
   +-(improvement >= threshold)-----> [Switch]
   |                                  |
   +-(no change)--------------------- [Selected]

[Switch] --> [Cooldown] --(cooldown expires)--> [Selected]
```

---

## Part 6: Bootstrapping and Convergence

When coordinates are missing or immature:

- Enter **Coordinate-Unaware Mode**
- Rank by capacity, then queue depth, then circuit pressure
- Exit when:
  - `sample_count >= MIN_SAMPLES_FOR_ROUTING` and
  - `error_ms <= ERROR_MAX_FOR_ROUTING`

This prevents early-stage noise from destabilizing routing.

---

## Part 7: Fallback Chain Construction

1. Select `primary_dcs` from `primary_bucket` in score order (with hysteresis)
2. Add remaining DCs from `primary_bucket` as fallback
3. Append next buckets in order (BUSY, then DEGRADED), each sorted by score

This yields a deterministic fallback chain that preserves AD-17 semantics.

---

## Part 8: Manager Selection Within a Datacenter

Managers are ranked similarly (within a DC):

- Exclude circuit-open or stale managers
- Score by RTT UCB + manager load + quality penalty
- Apply per-job stickiness: reuse the manager that already accepted the job in this DC

---

## Part 9: Routing Decision Flow

```
+--------------------------------------------------------------+
| Gate receives job                                            |
+--------------------------------------------------------------+
| 1) Filter DCs (exclude UNHEALTHY)                            |
| 2) Bucket by health (AD-17)                                  |
| 3) Score within primary bucket (RTT UCB x load x quality)    |
| 4) Apply hysteresis/stickiness                               |
| 5) Select primary_dcs and fallback_dcs                       |
+--------------------------------------------------------------+
```

---

## Part 10: Timing Diagram (Dispatch + Fallback)

```
Time ->

Gate               DC-A Manager          DC-B Manager
 |-- dispatch A -->|
 |<-- reject -------|
 |-- fallback B ------------------------->|
 |<-- accept --------------------------------|
 |-- record leader ------------------------>|
```

---

## Part 11: Observability

**Metrics**:
- `routing_decisions_total{bucket,reason}`
- `routing_score{dc_id}`
- `routing_score_component{dc_id,component="rtt_ucb|load|quality"}`
- `routing_switch_total{reason}`
- `routing_hold_down_blocks_total`
- `routing_fallback_used_total{from_dc,to_dc}`

**Logs**:
- `RoutingDecision` with candidate list and score components
- `RoutingSwitch` with old/new DC and improvement ratio
- `RoutingCooldown` when a DC fails dispatch

---

## Part 12: Success Criteria

1. **Latency Reduction**: 50% lower median RTT than random routing
2. **Load Distribution**: load variation coefficient < 0.3
3. **Failover Speed**: < 10 seconds from DC failure to routing around it
4. **Stability**: switch rate < 1% of routing decisions
5. **Zero Configuration**: no static priority lists required

---

## Conclusion

AD-36 uses AD-35's conservative RTT UCB and AD-17's health ordering to route jobs safely and efficiently.
The combination is robust against noisy coordinates, high load, and WAN variability, while avoiding routing churn.
