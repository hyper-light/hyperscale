---
ad_number: 21
name: Unified Retry Framework with Jitter
description: Provides consistent retry with exponential backoff and multiple jitter strategies
---

# AD-21: Unified Retry Framework with Jitter

**Decision**: Implement a unified retry framework with exponential backoff and jitter for all network operations.

**Rationale**:
- Scattered retry implementations lead to inconsistency
- Without jitter, retries cause thundering herd
- Different jitter strategies suit different scenarios
- Framework enables consistent timeout and backoff across codebase

**Jitter Strategies**:
```
┌─────────────────────────────────────────────────────────────────┐
│                       Jitter Strategies                         │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Full Jitter (default for most operations):                    │
│  ├─ delay = random(0, min(cap, base * 2^attempt))              │
│  ├─ Best for independent clients                               │
│  └─ Maximum spread, minimum correlation                        │
│                                                                 │
│  Equal Jitter (for operations needing minimum delay):          │
│  ├─ temp = min(cap, base * 2^attempt)                          │
│  ├─ delay = temp/2 + random(0, temp/2)                         │
│  └─ Guarantees minimum delay while spreading                   │
│                                                                 │
│  Decorrelated Jitter (for AWS-style retries):                  │
│  ├─ delay = random(base, previous_delay * 3)                   │
│  ├─ Each retry depends on previous                             │
│  └─ Good spread with bounded growth                            │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**Implementation**:
```python
class JitterStrategy(Enum):
    FULL = "full"
    EQUAL = "equal"
    DECORRELATED = "decorrelated"

@dataclass
class RetryConfig:
    """Configuration for retry behavior."""
    max_attempts: int = 3
    base_delay: float = 0.5  # seconds
    max_delay: float = 30.0  # cap
    jitter: JitterStrategy = JitterStrategy.FULL
    retryable_exceptions: tuple[type[Exception], ...] = (
        ConnectionError,
        TimeoutError,
        OSError,
    )

class RetryExecutor:
    """Unified retry execution with jitter."""

    def __init__(self, config: RetryConfig | None = None):
        self._config = config or RetryConfig()
        self._previous_delay: float = self._config.base_delay

    def calculate_delay(self, attempt: int) -> float:
        """Calculate delay with jitter for given attempt."""
        base = self._config.base_delay
        cap = self._config.max_delay

        if self._config.jitter == JitterStrategy.FULL:
            temp = min(cap, base * (2 ** attempt))
            return random.uniform(0, temp)

        elif self._config.jitter == JitterStrategy.EQUAL:
            temp = min(cap, base * (2 ** attempt))
            return temp / 2 + random.uniform(0, temp / 2)

        elif self._config.jitter == JitterStrategy.DECORRELATED:
            delay = random.uniform(base, self._previous_delay * 3)
            delay = min(cap, delay)
            self._previous_delay = delay
            return delay

        return base * (2 ** attempt)  # fallback: no jitter

    async def execute(
        self,
        operation: Callable[[], Awaitable[T]],
        operation_name: str = "operation",
    ) -> T:
        """Execute operation with retry and jitter."""
        last_exception: Exception | None = None

        for attempt in range(self._config.max_attempts):
            try:
                return await operation()
            except self._config.retryable_exceptions as exc:
                last_exception = exc
                if attempt < self._config.max_attempts - 1:
                    delay = self.calculate_delay(attempt)
                    await asyncio.sleep(delay)

        raise last_exception or RuntimeError(f"{operation_name} failed")
```

**Where Jitter Is Applied**:
- Health check intervals
- Retry delays
- Heartbeat timing
- State sync intervals
- Leader election timeouts
- Reconnection attempts
