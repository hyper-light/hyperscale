---
ad_number: 24
name: Rate Limiting (Client and Server)
description: Token bucket rate limiting at both client and server sides for fair sharing
---

# AD-24: Rate Limiting (Client and Server)

**Decision**: Implement token bucket rate limiting at both client and server sides.

**Rationale**:
- Prevents any single client from overwhelming the system
- Server-side is authoritative; client-side is cooperative
- Token bucket allows bursts while enforcing average rate
- Per-client tracking enables fair sharing

**Implementation**:
```
┌─────────────────────────────────────────────────────────────────┐
│                    Rate Limiting Architecture                   │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Client-Side (cooperative):                                     │
│  ├─ Pre-flight check before sending                            │
│  ├─ Respects server's rate limit headers                       │
│  └─ Delays requests when approaching limit                     │
│                                                                 │
│  Server-Side (authoritative):                                   │
│  ├─ Per-client token buckets                                   │
│  ├─ Returns 429 with Retry-After when exceeded                 │
│  └─ Different limits for different operation types             │
│                                                                 │
│  Token Bucket Parameters:                                       │
│  ├─ bucket_size: Maximum burst capacity                        │
│  ├─ refill_rate: Tokens added per second                       │
│  └─ current_tokens: Available tokens                           │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

```python
class TokenBucket:
    """Token bucket rate limiter."""

    def __init__(self, bucket_size: int, refill_rate: float):
        self._bucket_size = bucket_size
        self._refill_rate = refill_rate
        self._tokens = float(bucket_size)
        self._last_refill = time.monotonic()
        self._lock = asyncio.Lock()

    async def acquire(self, tokens: int = 1) -> bool:
        """Try to acquire tokens. Returns False if rate limited."""
        async with self._lock:
            self._refill()
            if self._tokens >= tokens:
                self._tokens -= tokens
                return True
            return False

    def _refill(self) -> None:
        """Refill tokens based on elapsed time."""
        now = time.monotonic()
        elapsed = now - self._last_refill
        self._tokens = min(
            self._bucket_size,
            self._tokens + elapsed * self._refill_rate
        )
        self._last_refill = now

class ServerRateLimiter:
    """Server-side rate limiter with per-client buckets."""

    def __init__(self, default_config: RateLimitConfig):
        self._config = default_config
        self._buckets: dict[str, TokenBucket] = {}

    def check_rate_limit(self, client_id: str, operation: str) -> tuple[bool, float]:
        """Check if request is allowed. Returns (allowed, retry_after)."""
        bucket = self._get_or_create_bucket(client_id, operation)
        if bucket.acquire(1):
            return True, 0.0
        else:
            retry_after = 1.0 / bucket._refill_rate
            return False, retry_after
```
