---
ad_number: 45
name: Adaptive Route Learning
description: EWMA-based observed latency tracking blended with Vivaldi RTT predictions for improved routing decisions.
---

# AD-45: Adaptive Route Learning

## Part 1: Problem Statement

**Current Limitation**:

AD-36 routes jobs using **predicted latency** from Vivaldi coordinates (RTT UCB). While this works well for network topology awareness, it doesn't learn from **actual job execution latency** - the real metric that matters for user experience.

### The Routing Latency Gap

```
CURRENT: Vivaldi RTT UCB only

Vivaldi estimates: dc-east 45ms RTT, dc-west 80ms RTT
-> Route to dc-east (lower RTT)

BUT reality:
  dc-east: congested network, slow workers
  Actual job completion: 2.5 seconds

  dc-west: idle network, fast workers
  Actual job completion: 0.8 seconds
```

**Why RTT Alone Is Insufficient**:
1. RTT measures network round-trip - just one component of total latency
2. No execution context - two DCs with same RTT can have very different execution times
3. No learning from outcomes - system never improves from actual results
4. Queue time invisible - AD-43 adds capacity awareness, but actual wait time may differ

**Missing Factors**:
- Worker execution speed (CPU, memory contention)
- Queue wait time (pending workflows)
- Serialization/deserialization overhead
- Workflow graph complexity differences
- DC-specific resource constraints

---

## Part 2: Design Overview

### Blended Latency Scoring

Combine **predicted latency** (Vivaldi RTT UCB) with **observed latency** (EWMA of actual job completions):

```
PREDICTED LATENCY (from AD-35/AD-36):
rtt_ucb_ms = estimate_rtt_ucb_ms(local_coord, dc_coord)

OBSERVED LATENCY (new in AD-45):
observed_ms = EWMA of actual job completion times per DC

BLENDED LATENCY:
confidence = min(1.0, sample_count / MIN_SAMPLES_FOR_CONFIDENCE)
blended_ms = (confidence * observed_ms) + ((1 - confidence) * rtt_ucb_ms)

INTEGRATION WITH AD-36:
final_score = blended_ms * load_factor * quality_penalty
```

### Key Properties

1. **Cold Start Safe**: New DCs use RTT UCB (confidence = 0)
2. **Progressive Learning**: As samples accumulate, observed latency gains weight
3. **Never Forgets Prediction**: RTT UCB always contributes via (1 - confidence)
4. **Adapts to Changes**: EWMA decays old observations, responds to DC state changes
5. **Integrates Cleanly**: Replaces one input to existing AD-36 scoring

---

## Part 3: Observed Latency Tracking

### EWMA Model

```python
@dataclass(slots=True)
class ObservedLatencyState:
    datacenter_id: str
    ewma_ms: float = 0.0            # Current EWMA estimate
    sample_count: int = 0           # Total samples recorded
    last_update: float = 0.0        # Monotonic time of last update
    ewma_variance: float = 0.0      # For confidence intervals

    def record_latency(self, latency_ms: float, alpha: float) -> None:
        """Record observed job completion latency."""

    def get_confidence(self, min_samples: int) -> float:
        """Confidence ramps from 0 to 1 as samples increase."""
```

### ObservedLatencyTracker

Each gate maintains its own view of DC latencies:

```python
@dataclass
class ObservedLatencyTracker:
    alpha: float = 0.1                      # EWMA decay
    min_samples_for_confidence: int = 10
    max_staleness_seconds: float = 300.0

    def record_job_latency(self, datacenter_id: str, latency_ms: float) -> None
    def get_observed_latency(self, datacenter_id: str) -> tuple[float, float]
    def get_blended_latency(self, datacenter_id: str, predicted_rtt_ms: float) -> float
```

---

## Part 4: Job Latency Measurement

### What We Measure

Job completion latency from the gate's perspective:
- **Start**: Gate dispatches job to datacenter
- **End**: Gate receives final result from datacenter

This captures: network + queue + execution + network return

### Implementation

```python
class GateJobManager:
    _dispatch_times: dict[tuple[str, str], float]  # (job_id, dc_id) -> dispatch_time

    async def dispatch_to_datacenter(self, job_id: str, datacenter_id: str) -> bool:
        self._dispatch_times[(job_id, datacenter_id)] = monotonic()
        # ... dispatch logic ...

    async def record_datacenter_result(self, job_id: str, datacenter_id: str, success: bool) -> None:
        if success:
            latency_ms = (monotonic() - dispatch_time) * 1000
            self._observed_latency_tracker.record_job_latency(datacenter_id, latency_ms)
```

---

## Part 5: Integration with AD-36 Routing

### Modified RoutingScorer

```python
class RoutingScorer:
    def score_datacenters(self, candidates: list[DatacenterCandidate]) -> list[DatacenterRoutingScore]:
        for candidate in candidates:
            if self._config.use_blended_latency:
                # AD-45: Blended latency
                latency_ms = self._observed_latency_tracker.get_blended_latency(
                    datacenter_id=candidate.datacenter_id,
                    predicted_rtt_ms=candidate.rtt_ucb_ms,
                )
            else:
                # AD-36: RTT UCB only
                latency_ms = candidate.rtt_ucb_ms

            final_score = latency_ms * load_factor * quality_penalty
```

---

## Part 6: EWMA Tuning and Decay

### Alpha Selection

| Alpha | Behavior | Half-life |
|-------|----------|-----------|
| 0.1 | Slow, stable, good for steady-state | ~7 samples |
| 0.2 | Balanced (recommended default) | ~3-4 samples |
| 0.3 | Responsive, moderate noise sensitivity | ~2 samples |
| 0.5 | Quick response, sensitive to outliers | ~1 sample |

### Staleness Confidence Decay

When no jobs are routed to a DC, observations become stale:

| Time Since Update | Confidence Multiplier |
|-------------------|----------------------|
| 0 seconds | 1.0 (full confidence) |
| 60 seconds | 0.8 |
| 120 seconds | 0.6 |
| 180 seconds | 0.4 |
| 240 seconds | 0.2 |
| 300+ seconds | 0.0 (fall back to prediction only) |

---

## Part 7: Environment Configuration

```python
# Adaptive Route Learning Settings (AD-45)
ROUTE_LEARNING_ENABLED: bool = True
ROUTE_LEARNING_EWMA_ALPHA: float = 0.2
ROUTE_LEARNING_MIN_SAMPLES: int = 10
ROUTE_LEARNING_MAX_STALENESS_SECONDS: float = 300.0
ROUTE_LEARNING_USE_BLENDED_LATENCY: bool = True
```

---

## Part 8: Observability

### Metrics

- `route_learning_observed_latency_ms{dc_id}`
- `route_learning_blended_latency_ms{dc_id}`
- `route_learning_confidence{dc_id}`
- `route_learning_sample_count{dc_id}`

### Logs

- `ObservedLatencyRecorded`: When job latency recorded
- `BlendedLatencyComputed`: Breakdown of predicted vs observed contribution
- `StaleObservationsDecayed`: When confidence reduced due to staleness
