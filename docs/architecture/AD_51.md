---
ad_number: 51
name: Unified Health-Aware Routing Integration
description: Integrates Vivaldi coordinates, multi-factor scoring, observed latency, capacity awareness, and health classification into a unified datacenter routing system.
---

# AD-51: Unified Health-Aware Routing Integration

**Status**: Implementation Ready
**Related**: AD-35 (Vivaldi Coordinates), AD-36 (Job Routing), AD-42 (SLO-Aware), AD-43 (Capacity Spillover), AD-45 (Adaptive Route Learning), AD-16 (Health Classification), AD-17 (Health Buckets)

---

## Part 1: Problem Statement

### Current State

The gate server has **two parallel routing systems** that are disconnected:

1. **Legacy Routing** (active):
   - Simple health bucket ordering (HEALTHY > BUSY > DEGRADED)
   - No latency awareness
   - No multi-factor scoring
   - No routing stability (hysteresis)

2. **Advanced Routing** (implemented but not wired):
   - `GateJobRouter` with full AD-36 implementation
   - `CoordinateTracker` for Vivaldi RTT estimation
   - `RoutingScorer` for multi-factor scoring
   - `HysteresisManager` for routing stability
   - `ObservedLatencyTracker` for learned latencies (AD-45)
   - `SpilloverEvaluator` for capacity-aware routing (AD-43)

### The Gap

```
CURRENT FLOW (Legacy):
┌─────────────────────────────────────────────────────────────────┐
│ _select_datacenters_with_fallback()                             │
│     → legacy_select_datacenters()                               │
│         → Simple bucket ordering                                │
│         → No Vivaldi, no scoring, no hysteresis                 │
└─────────────────────────────────────────────────────────────────┘

DESIRED FLOW (Unified):
┌─────────────────────────────────────────────────────────────────┐
│ GateJobRouter.route_job(job_id)                                 │
│     → Vivaldi RTT estimation                                    │
│     → Blended latency (predicted + observed)                    │
│     → Multi-factor scoring (RTT × load × quality)               │
│     → Health bucket selection                                   │
│     → Hysteresis for stability                                  │
│     → Capacity-aware spillover                                  │
│     → Per-job state cleanup                                     │
└─────────────────────────────────────────────────────────────────┘
```

---

## Part 2: Architecture Overview

### Component Hierarchy

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                              GateServer                                      │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                      GateJobRouter (AD-36)                          │   │
│  │  - Orchestrates all routing decisions                               │   │
│  │  - Maintains per-job routing state                                  │   │
│  │  - Applies hysteresis for stability                                 │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                    │                                        │
│          ┌─────────────────────────┼─────────────────────────┐              │
│          │                         │                         │              │
│          ▼                         ▼                         ▼              │
│  ┌───────────────┐     ┌───────────────────┐     ┌───────────────────┐     │
│  │ Coordinate    │     │  RoutingScorer    │     │ HysteresisManager │     │
│  │ Tracker       │     │                   │     │                   │     │
│  │ (AD-35)       │     │  RTT × load ×     │     │  Hold-down,       │     │
│  │               │     │  quality scoring  │     │  improvement      │     │
│  │  Vivaldi RTT  │     │                   │     │  threshold        │     │
│  └───────┬───────┘     └─────────┬─────────┘     └───────────────────┘     │
│          │                       │                                          │
│          │             ┌─────────┴─────────┐                                │
│          │             │                   │                                │
│          ▼             ▼                   ▼                                │
│  ┌───────────────┐  ┌─────────────┐  ┌─────────────────┐                   │
│  │ Blended       │  │ Candidate   │  │ BucketSelector  │                   │
│  │ Latency       │  │ Filter      │  │ (AD-17)         │                   │
│  │ Scorer        │  │ (AD-36)     │  │                 │                   │
│  │ (AD-45)       │  │             │  │ HEALTHY > BUSY  │                   │
│  │               │  │ Exclude     │  │ > DEGRADED      │                   │
│  │ Predicted +   │  │ unhealthy,  │  │                 │                   │
│  │ Observed      │  │ no managers │  │                 │                   │
│  └───────┬───────┘  └─────────────┘  └─────────────────┘                   │
│          │                                                                  │
│          ▼                                                                  │
│  ┌───────────────────────────────────────────────────────────────────┐     │
│  │                    ObservedLatencyTracker (AD-45)                  │     │
│  │  - EWMA of actual job completion latencies                        │     │
│  │  - Per-datacenter tracking                                        │     │
│  │  - Confidence-based blending with Vivaldi                         │     │
│  └───────────────────────────────────────────────────────────────────┘     │
│                                                                             │
│  ┌───────────────────────────────────────────────────────────────────┐     │
│  │                    GateHealthCoordinator                          │     │
│  │  - Datacenter health classification                               │     │
│  │  - Manager heartbeat processing                                   │     │
│  │  - Builds DatacenterCandidate objects                             │     │
│  └───────────────────────────────────────────────────────────────────┘     │
│                                                                             │
│  ┌───────────────────────────────────────────────────────────────────┐     │
│  │               DatacenterCapacityAggregator (AD-43)                │     │
│  │  - Aggregates capacity from manager heartbeats                    │     │
│  │  - Provides wait time estimation                                  │     │
│  └───────────────────────────────────────────────────────────────────┘     │
│                                                                             │
│  ┌───────────────────────────────────────────────────────────────────┐     │
│  │                   SpilloverEvaluator (AD-43)                      │     │
│  │  - Proactive cross-DC spillover                                   │     │
│  │  - Wait time vs latency tradeoff                                  │     │
│  └───────────────────────────────────────────────────────────────────┘     │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## Part 3: Data Flow

### Routing Decision Flow

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         ROUTING DECISION FLOW                               │
└─────────────────────────────────────────────────────────────────────────────┘

1. JOB SUBMISSION
   │
   ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│ GateDispatchCoordinator receives JobSubmission                              │
│   job_id, preferred_datacenters, workflow_count                             │
└─────────────────────────────────────────────────────────────────────────────┘
   │
   ▼
2. ROUTE JOB
   │
   ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│ GateJobRouter.route_job(job_id, preferred_datacenters)                      │
└─────────────────────────────────────────────────────────────────────────────┘
   │
   ├──► 2a. Get/Create Job Routing State
   │         │
   │         ▼
   │    ┌─────────────────────────────────────────────────────────────────┐
   │    │ RoutingStateManager.get_or_create_state(job_id)                 │
   │    │   - Primary datacenter (sticky)                                 │
   │    │   - Selection timestamp (for hold-down)                         │
   │    │   - Cooldown map (recently failed DCs)                          │
   │    └─────────────────────────────────────────────────────────────────┘
   │
   ├──► 2b. Get Datacenter Candidates
   │         │
   │         ▼
   │    ┌─────────────────────────────────────────────────────────────────┐
   │    │ GateHealthCoordinator.build_datacenter_candidates()             │
   │    │   Returns: List[DatacenterCandidate]                            │
   │    │     - datacenter_id                                             │
   │    │     - health_bucket (HEALTHY/BUSY/DEGRADED/UNHEALTHY)           │
   │    │     - available_cores, total_cores, queue_depth                 │
   │    │     - total_managers, healthy_managers                          │
   │    └─────────────────────────────────────────────────────────────────┘
   │
   ├──► 2c. Enrich with Vivaldi RTT
   │         │
   │         ▼
   │    ┌─────────────────────────────────────────────────────────────────┐
   │    │ For each candidate:                                             │
   │    │   peer_coord = CoordinateTracker.get_peer_coordinate(dc_leader) │
   │    │   rtt_ucb_ms = CoordinateTracker.estimate_rtt_ucb_ms(peer_coord)│
   │    │   quality = CoordinateTracker.coordinate_quality(peer_coord)    │
   │    │                                                                 │
   │    │   # Blend with observed latency (AD-45)                         │
   │    │   blended_ms = BlendedLatencyScorer.get_latency_for_scoring(    │
   │    │       datacenter_id, rtt_ucb_ms, use_blending=True              │
   │    │   )                                                             │
   │    │                                                                 │
   │    │   candidate.rtt_ucb_ms = blended_ms                             │
   │    │   candidate.coordinate_quality = quality                        │
   │    │   candidate.has_coordinate = True                               │
   │    └─────────────────────────────────────────────────────────────────┘
   │
   ├──► 2d. Filter Candidates
   │         │
   │         ▼
   │    ┌─────────────────────────────────────────────────────────────────┐
   │    │ CandidateFilter.filter_datacenters(candidates)                  │
   │    │                                                                 │
   │    │ HARD EXCLUDES:                                                  │
   │    │   - health_bucket == "UNHEALTHY"                                │
   │    │   - total_managers == 0                                         │
   │    │   - healthy_managers == 0 (all circuits open)                   │
   │    │                                                                 │
   │    │ SOFT DEMOTIONS:                                                 │
   │    │   - Missing coordinates → use default RTT                       │
   │    │   - Stale health → treat as DEGRADED                            │
   │    │                                                                 │
   │    │ Returns: (eligible, excluded)                                   │
   │    └─────────────────────────────────────────────────────────────────┘
   │
   ├──► 2e. Select Primary Bucket (AD-17 Preserved)
   │         │
   │         ▼
   │    ┌─────────────────────────────────────────────────────────────────┐
   │    │ BucketSelector.select_bucket(eligible_candidates)               │
   │    │                                                                 │
   │    │ Priority: HEALTHY > BUSY > DEGRADED                             │
   │    │                                                                 │
   │    │ Returns: BucketSelectionResult                                  │
   │    │   - primary_bucket: str                                         │
   │    │   - primary_candidates: List[DatacenterCandidate]               │
   │    │   - fallback_candidates: List[DatacenterCandidate]              │
   │    └─────────────────────────────────────────────────────────────────┘
   │
   ├──► 2f. Check Bootstrap Mode
   │         │
   │         ▼
   │    ┌─────────────────────────────────────────────────────────────────┐
   │    │ BootstrapModeManager.check_bootstrap()                          │
   │    │                                                                 │
   │    │ Bootstrap mode if:                                              │
   │    │   - sample_count < MIN_SAMPLES_FOR_ROUTING (10)                 │
   │    │   - error_ms > ERROR_MAX_FOR_ROUTING                            │
   │    │                                                                 │
   │    │ In bootstrap: rank by capacity, not RTT                         │
   │    └─────────────────────────────────────────────────────────────────┘
   │
   ├──► 2g. Score Candidates
   │         │
   │         ▼
   │    ┌─────────────────────────────────────────────────────────────────┐
   │    │ RoutingScorer.score_datacenters(primary_candidates, preferred)  │
   │    │                                                                 │
   │    │ SCORING FORMULA (lower is better):                              │
   │    │                                                                 │
   │    │   load_factor = 1.0 + A_UTIL*util + A_QUEUE*queue + A_CB*cb     │
   │    │   quality_penalty = 1.0 + A_QUALITY*(1.0 - quality)             │
   │    │   score = rtt_ucb_ms * load_factor * quality_penalty            │
   │    │                                                                 │
   │    │   if preferred: score *= PREFERENCE_MULT (0.9)                  │
   │    │                                                                 │
   │    │ Returns: List[DatacenterRoutingScore] sorted by score           │
   │    └─────────────────────────────────────────────────────────────────┘
   │
   ├──► 2h. Apply Cooldown Penalties
   │         │
   │         ▼
   │    ┌─────────────────────────────────────────────────────────────────┐
   │    │ HysteresisManager.apply_cooldown_penalty(scores, job_state)     │
   │    │                                                                 │
   │    │ For DCs in cooldown (recent dispatch failures):                 │
   │    │   score *= COOLDOWN_PENALTY_MULTIPLIER (2.0)                    │
   │    └─────────────────────────────────────────────────────────────────┘
   │
   ├──► 2i. Apply Hysteresis
   │         │
   │         ▼
   │    ┌─────────────────────────────────────────────────────────────────┐
   │    │ HysteresisManager.evaluate_switch(job_state, scores, excluded)  │
   │    │                                                                 │
   │    │ SWITCH CONDITIONS:                                              │
   │    │   - Current primary excluded → FORCED switch                    │
   │    │   - Current primary dropped bucket → FORCED switch              │
   │    │   - Hold-down period active → RETAIN current                    │
   │    │   - New best improves by IMPROVEMENT_RATIO → SWITCH             │
   │    │   - Otherwise → RETAIN current                                  │
   │    │                                                                 │
   │    │ Returns: HysteresisResult                                       │
   │    │   - should_switch: bool                                         │
   │    │   - selected_datacenter: str                                    │
   │    │   - reason: RoutingDecisionReason                               │
   │    └─────────────────────────────────────────────────────────────────┘
   │
   ├──► 2j. Build Fallback Chain
   │         │
   │         ▼
   │    ┌─────────────────────────────────────────────────────────────────┐
   │    │ FallbackChainBuilder.build_chain(primary_scores, fallback_cands)│
   │    │                                                                 │
   │    │ Chain construction:                                             │
   │    │   1. Primary DCs from primary_bucket (up to max_primary_dcs)    │
   │    │   2. Remaining primary_bucket DCs as fallback                   │
   │    │   3. Next bucket DCs sorted by score                            │
   │    │                                                                 │
   │    │ Returns: FallbackChain                                          │
   │    │   - primary_datacenters: List[str]                              │
   │    │   - fallback_datacenters: List[str]                             │
   │    │   - scores: Dict[str, float]                                    │
   │    └─────────────────────────────────────────────────────────────────┘
   │
   ▼
3. RETURN ROUTING DECISION
   │
   ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│ RoutingDecision                                                             │
│   - job_id: str                                                             │
│   - primary_datacenters: List[str]                                          │
│   - fallback_datacenters: List[str]                                         │
│   - primary_bucket: str                                                     │
│   - reason: RoutingDecisionReason                                           │
│   - in_bootstrap_mode: bool                                                 │
│   - scores: Dict[str, float]                                                │
│   - switched: bool                                                          │
│   - previous_primary: str | None                                            │
└─────────────────────────────────────────────────────────────────────────────┘
   │
   ▼
4. DISPATCH TO SELECTED DCS
   │
   ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│ GateDispatchCoordinator._dispatch_job_with_fallback()                       │
│   - Try primary DCs first                                                   │
│   - On failure, try fallback DCs                                            │
│   - On success, record latency for learning                                 │
└─────────────────────────────────────────────────────────────────────────────┘
   │
   ├──► 4a. On Dispatch Success
   │         │
   │         ▼
   │    ┌─────────────────────────────────────────────────────────────────┐
   │    │ Record completion latency for AD-45 learning:                   │
   │    │   latency_ms = (completion_time - dispatch_time) * 1000         │
   │    │   ObservedLatencyTracker.record_job_latency(dc_id, latency_ms)  │
   │    └─────────────────────────────────────────────────────────────────┘
   │
   ├──► 4b. On Dispatch Failure
   │         │
   │         ▼
   │    ┌─────────────────────────────────────────────────────────────────┐
   │    │ Record failure for cooldown:                                    │
   │    │   GateJobRouter.record_dispatch_failure(job_id, dc_id)          │
   │    │   → Adds DC to cooldown map with expiration                     │
   │    └─────────────────────────────────────────────────────────────────┘
   │
   ▼
5. JOB CLEANUP (on completion/failure/timeout)
   │
   ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│ _cleanup_single_job(job_id)                                                 │
│   ...existing cleanup...                                                    │
│   GateJobRouter.cleanup_job_state(job_id)  ← NEW                            │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## Part 4: Scoring Algorithm

### Multi-Factor Score Formula

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         SCORING FORMULA                                     │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   final_score = rtt_ms × load_factor × quality_penalty × preference_mult    │
│                 × health_severity_weight                                    │
│                                                                             │
│   Where:                                                                    │
│                                                                             │
│   rtt_ms = BlendedLatencyScorer.get_latency_for_scoring(                    │
│       datacenter_id,                                                        │
│       predicted_rtt_ms=CoordinateTracker.estimate_rtt_ucb_ms(),             │
│       use_blending=True                                                     │
│   )                                                                         │
│                                                                             │
│   load_factor = 1.0 + A_UTIL*utilization + A_QUEUE*queue + A_CB*cb_pressure │
│   load_factor = min(load_factor, LOAD_FACTOR_MAX)                           │
│                                                                             │
│   quality_penalty = 1.0 + A_QUALITY*(1.0 - coordinate_quality)              │
│   quality_penalty = min(quality_penalty, QUALITY_PENALTY_MAX)               │
│                                                                             │
│   preference_mult = 0.9 if datacenter in preferred_set else 1.0             │
│                                                                             │
│   health_severity_weight = based on health bucket severity                  │
│                                                                             │
│   LOWER SCORE = BETTER                                                      │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### Scoring Constants

```python
# Load factor weights
A_UTIL = 0.5      # Utilization contribution
A_QUEUE = 0.3     # Queue depth contribution
A_CB = 0.2        # Circuit breaker pressure contribution
QUEUE_SMOOTHING = 10.0
LOAD_FACTOR_MAX = 5.0

# Quality penalty weights
A_QUALITY = 0.5
QUALITY_PENALTY_MAX = 2.0

# Preference
PREFERENCE_MULTIPLIER = 0.9  # 10% bonus for preferred DCs

# Cooldown
COOLDOWN_PENALTY_MULTIPLIER = 2.0  # Double score for recently failed DCs
COOLDOWN_SECONDS = 60.0

# Hysteresis
HOLD_DOWN_SECONDS = 30.0
IMPROVEMENT_RATIO = 0.8  # Must be 20% better to switch
```

### Blended Latency Formula (AD-45)

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                       BLENDED LATENCY (AD-45)                               │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   confidence = min(1.0, sample_count / MIN_SAMPLES_FOR_CONFIDENCE)          │
│                                                                             │
│   blended_ms = (confidence × observed_ms) + ((1 - confidence) × rtt_ucb_ms) │
│                                                                             │
│   Where:                                                                    │
│     observed_ms = EWMA of actual job completion latencies                   │
│     rtt_ucb_ms = Vivaldi RTT upper confidence bound                         │
│                                                                             │
│   Properties:                                                               │
│     - confidence=0 (cold start): use pure Vivaldi RTT                       │
│     - confidence=1 (mature): use pure observed latency                      │
│     - 0<confidence<1: blend both signals                                    │
│                                                                             │
│   Staleness decay:                                                          │
│     If no samples for MAX_STALENESS_SECONDS (300s):                         │
│       confidence decays linearly to 0                                       │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## Part 5: State Diagrams

### Job Routing State Lifecycle

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    JOB ROUTING STATE LIFECYCLE                              │
└─────────────────────────────────────────────────────────────────────────────┘

                              ┌─────────────┐
                              │   Created   │
                              │ (no primary)│
                              └──────┬──────┘
                                     │
                          First routing decision
                                     │
                                     ▼
                        ┌────────────────────────┐
                        │                        │
                        │   PRIMARY SELECTED     │◄────────────────┐
                        │                        │                 │
                        │  - primary_datacenter  │                 │
                        │  - selection_timestamp │     Hysteresis  │
                        │  - selection_score     │     allows      │
                        │                        │     switch      │
                        └───────────┬────────────┘                 │
                                    │                              │
              ┌─────────────────────┼─────────────────────┐        │
              │                     │                     │        │
              ▼                     ▼                     ▼        │
     ┌────────────────┐  ┌────────────────┐  ┌────────────────┐   │
     │  Hold-down     │  │ Primary        │  │ Improvement    │   │
     │  active        │  │ excluded       │  │ threshold met  │   │
     │                │  │                │  │                │   │
     │ RETAIN current │  │ FORCED switch  │  │ SWITCH allowed │   │
     └────────┬───────┘  └────────┬───────┘  └────────┬───────┘   │
              │                   │                   │            │
              │                   └─────────┬─────────┘            │
              │                             │                      │
              │                             ▼                      │
              │                    ┌────────────────┐              │
              │                    │  Select new    │              │
              │                    │  primary       │──────────────┘
              │                    └────────────────┘
              │
              │  (hold-down expires)
              │
              └──────────────────────────────────────────────────────►
                                                                    │
                                                              Normal │
                                                              routing│
                                                                    ▼

                              ┌─────────────┐
                              │   Cleanup   │
                              │             │
                              │ Job complete│
                              │ or timeout  │
                              └──────┬──────┘
                                     │
                    cleanup_job_state(job_id)
                                     │
                                     ▼
                              ┌─────────────┐
                              │   Removed   │
                              │             │
                              │ State freed │
                              └─────────────┘
```

### Datacenter Candidate State

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    DATACENTER CANDIDATE FILTERING                           │
└─────────────────────────────────────────────────────────────────────────────┘

                         ┌─────────────────┐
                         │   Raw Candidate │
                         │                 │
                         │ From heartbeats │
                         └────────┬────────┘
                                  │
                    Apply filtering rules
                                  │
              ┌───────────────────┼───────────────────┐
              │                   │                   │
              ▼                   ▼                   ▼
     ┌────────────────┐  ┌────────────────┐  ┌────────────────┐
     │ HARD EXCLUDE   │  │ SOFT DEMOTION  │  │ ELIGIBLE       │
     │                │  │                │  │                │
     │ - UNHEALTHY    │  │ - Stale health │  │ Pass all       │
     │ - No managers  │  │   → DEGRADED   │  │ checks         │
     │ - All circuits │  │ - Missing coord│  │                │
     │   open         │  │   → Default RTT│  │                │
     └────────┬───────┘  └────────┬───────┘  └────────┬───────┘
              │                   │                   │
              ▼                   │                   │
     ┌────────────────┐           │                   │
     │ Excluded from  │           │                   │
     │ selection      │           │                   │
     └────────────────┘           │                   │
                                  │                   │
                                  └─────────┬─────────┘
                                            │
                                            ▼
                                   ┌────────────────┐
                                   │ Bucket         │
                                   │ Selection      │
                                   │                │
                                   │ HEALTHY > BUSY │
                                   │ > DEGRADED     │
                                   └────────┬───────┘
                                            │
                                            ▼
                                   ┌────────────────┐
                                   │ Scoring &      │
                                   │ Ranking        │
                                   │                │
                                   │ Within bucket  │
                                   └────────────────┘
```

---

## Part 6: Vivaldi Coordinate Flow

### RTT Measurement and Coordinate Update

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    VIVALDI COORDINATE UPDATE FLOW                           │
└─────────────────────────────────────────────────────────────────────────────┘

1. OUTBOUND PING/REQUEST
   │
   ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│ Gate sends message to Manager/Gate                                          │
│                                                                             │
│ Message includes:                                                           │
│   - Gate's Vivaldi coordinate                                               │
│   - Request timestamp                                                       │
│                                                                             │
│ start_time = monotonic()                                                    │
└─────────────────────────────────────────────────────────────────────────────┘
   │
   ▼
2. RESPONSE RECEIVED
   │
   ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│ Gate receives response                                                      │
│                                                                             │
│ Response includes:                                                          │
│   - Peer's Vivaldi coordinate                                               │
│                                                                             │
│ end_time = monotonic()                                                      │
│ rtt_ms = (end_time - start_time) * 1000                                     │
└─────────────────────────────────────────────────────────────────────────────┘
   │
   ▼
3. UPDATE COORDINATE TRACKER
   │
   ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│ CoordinateTracker.update_peer_coordinate(                                   │
│     peer_id=peer_address,                                                   │
│     peer_coordinate=response.coordinate,                                    │
│     rtt_ms=rtt_ms                                                           │
│ )                                                                           │
│                                                                             │
│ Internally:                                                                 │
│   1. Store peer's coordinate for future RTT estimation                      │
│   2. Update local coordinate to minimize prediction error:                  │
│                                                                             │
│      predicted_rtt = distance(local_coord, peer_coord)                      │
│      error = measured_rtt - predicted_rtt                                   │
│      local_coord += delta * error * unit_vector                             │
│                                                                             │
│   3. Update sample count and error estimate                                 │
└─────────────────────────────────────────────────────────────────────────────┘
   │
   ▼
4. USE FOR ROUTING
   │
   ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│ When routing decisions needed:                                              │
│                                                                             │
│   rtt_ucb_ms = CoordinateTracker.estimate_rtt_ucb_ms(peer_coord)            │
│                                                                             │
│   RTT UCB = predicted_rtt + K_SIGMA * (local_error + peer_error)            │
│                                                                             │
│   Conservative estimate that accounts for coordinate uncertainty            │
└─────────────────────────────────────────────────────────────────────────────┘
```

### Coordinate Quality Assessment

```python
def coordinate_quality(sample_count: int, error_ms: float, staleness_s: float) -> float:
    """
    Compute coordinate quality score in [0.0, 1.0].
    
    Factors:
    - sample_count: More samples = higher quality
    - error_ms: Lower error = higher quality
    - staleness_s: Fresher = higher quality
    """
    MIN_SAMPLES = 10
    ERROR_GOOD_MS = 20.0
    COORD_TTL_S = 300.0
    
    sample_quality = min(1.0, sample_count / MIN_SAMPLES)
    error_quality = min(1.0, ERROR_GOOD_MS / max(error_ms, 1.0))
    staleness_quality = 1.0 if staleness_s <= COORD_TTL_S else COORD_TTL_S / staleness_s
    
    return max(0.0, min(1.0, sample_quality * error_quality * staleness_quality))
```

---

## Part 7: Example Routing Decisions

### Example 1: Normal Routing (Converged Coordinates)

```
SCENARIO: Job submitted, coordinates converged, all DCs healthy

INPUT:
  job_id = "job-abc123"
  preferred_datacenters = {"us-east-1"}
  
CANDIDATES:
  ┌─────────────┬────────────┬──────────┬───────────┬─────────┬─────────┐
  │ Datacenter  │ Health     │ RTT UCB  │ Observed  │ Blended │ Load    │
  │             │ Bucket     │ (Vivaldi)│ Latency   │ Latency │ Factor  │
  ├─────────────┼────────────┼──────────┼───────────┼─────────┼─────────┤
  │ us-east-1   │ HEALTHY    │ 15ms     │ 18ms      │ 17ms    │ 1.2     │
  │ us-west-2   │ HEALTHY    │ 65ms     │ 72ms      │ 70ms    │ 1.1     │
  │ eu-west-1   │ HEALTHY    │ 120ms    │ N/A       │ 120ms   │ 1.0     │
  │ ap-south-1  │ BUSY       │ 200ms    │ 180ms     │ 185ms   │ 1.8     │
  └─────────────┴────────────┴──────────┴───────────┴─────────┴─────────┘

SCORING (primary bucket = HEALTHY):
  us-east-1: 17ms × 1.2 × 1.0 × 0.9 (preferred) = 18.36
  us-west-2: 70ms × 1.1 × 1.0 × 1.0            = 77.00
  eu-west-1: 120ms × 1.0 × 1.05 (low quality)  = 126.00

RESULT:
  RoutingDecision(
      primary_datacenters = ["us-east-1", "us-west-2"],
      fallback_datacenters = ["eu-west-1", "ap-south-1"],
      primary_bucket = "HEALTHY",
      reason = INITIAL_SELECTION
  )
```

### Example 2: Bootstrap Mode (Coordinates Not Converged)

```
SCENARIO: New gate, coordinates still converging

INPUT:
  job_id = "job-def456"
  coordinate_sample_count = 3  (< MIN_SAMPLES=10)
  
CANDIDATES:
  ┌─────────────┬────────────┬──────────┬───────────┬─────────┐
  │ Datacenter  │ Health     │ Available│ Total     │ Queue   │
  │             │ Bucket     │ Cores    │ Cores     │ Depth   │
  ├─────────────┼────────────┼──────────┼───────────┼─────────┤
  │ us-east-1   │ HEALTHY    │ 200      │ 500       │ 5       │
  │ us-west-2   │ HEALTHY    │ 400      │ 500       │ 2       │
  │ eu-west-1   │ HEALTHY    │ 100      │ 500       │ 20      │
  └─────────────┴────────────┴──────────┴───────────┴─────────┘

BOOTSTRAP RANKING (by capacity, not RTT):
  1. us-west-2: 400 available, queue=2  → Best
  2. us-east-1: 200 available, queue=5  → Second
  3. eu-west-1: 100 available, queue=20 → Third

RESULT:
  RoutingDecision(
      primary_datacenters = ["us-west-2", "us-east-1"],
      fallback_datacenters = ["eu-west-1"],
      primary_bucket = "HEALTHY",
      reason = INITIAL_SELECTION,
      in_bootstrap_mode = True
  )
```

### Example 3: Hysteresis Retention

```
SCENARIO: Existing job, current primary still good

INPUT:
  job_id = "job-ghi789"
  current_primary = "us-east-1"
  selection_timestamp = 15 seconds ago (< HOLD_DOWN=30s)
  
CANDIDATES:
  us-east-1: score = 25.0 (current primary)
  us-west-2: score = 22.0 (slightly better)

HYSTERESIS CHECK:
  - Hold-down active: 15s < 30s → RETAIN
  - Even though us-west-2 is better, within hold-down period

RESULT:
  RoutingDecision(
      primary_datacenters = ["us-east-1", "us-west-2"],
      reason = HOLD_DOWN_RETAINED,
      switched = False
  )
```

### Example 4: Forced Switch (Primary Excluded)

```
SCENARIO: Current primary became unhealthy

INPUT:
  job_id = "job-jkl012"
  current_primary = "us-east-1"
  
CANDIDATES:
  us-east-1: EXCLUDED (health_bucket = "UNHEALTHY")
  us-west-2: score = 45.0
  eu-west-1: score = 80.0

HYSTERESIS CHECK:
  - Current primary excluded → FORCED switch

RESULT:
  RoutingDecision(
      primary_datacenters = ["us-west-2", "eu-west-1"],
      reason = EXCLUSION_FORCED,
      switched = True,
      previous_primary = "us-east-1"
  )
```

### Example 5: Cooldown Penalty

```
SCENARIO: Previous dispatch to us-east-1 failed

INPUT:
  job_id = "job-mno345"
  cooldown_map = {"us-east-1": expires_in_45_seconds}
  
CANDIDATES (before cooldown):
  us-east-1: score = 20.0
  us-west-2: score = 35.0

AFTER COOLDOWN PENALTY:
  us-east-1: score = 20.0 × 2.0 = 40.0
  us-west-2: score = 35.0

RESULT:
  RoutingDecision(
      primary_datacenters = ["us-west-2", "us-east-1"],
      reason = COOLDOWN_PENALTY
  )
```

---

## Part 8: Implementation Examples

### 8.1 CoordinateTracker Initialization

```python
# In GateServer.__init__

from hyperscale.distributed.swim.coordinates import CoordinateTracker
from hyperscale.distributed.models.coordinates import VivaldiConfig

# Initialize coordinate tracker
self._coordinate_tracker = CoordinateTracker(
    config=VivaldiConfig(
        dimensions=4,
        initial_error=100.0,
        ce=0.25,          # Coordinate error weight
        cc=0.25,          # Confidence weight
        rtt_min_ms=1.0,
        rtt_max_ms=2000.0,
        min_samples_for_routing=10,
        error_max_for_routing=50.0,
        coord_ttl_seconds=300.0,
    )
)
```

### 8.2 Coordinate Update on RTT Measurement

```python
# When receiving response from peer with measured RTT

async def _on_peer_response(
    self,
    peer_id: str,
    peer_coordinate: NetworkCoordinate,
    rtt_ms: float,
) -> None:
    """Update coordinate tracker with RTT measurement."""
    if rtt_ms > 0 and peer_coordinate is not None:
        self._coordinate_tracker.update_peer_coordinate(
            peer_id=peer_id,
            peer_coordinate=peer_coordinate,
            rtt_ms=rtt_ms,
        )
```

### 8.3 GateJobRouter Initialization

```python
# In GateServer.__init__

from hyperscale.distributed.routing import (
    GateJobRouter,
    GateJobRouterConfig,
    ScoringConfig,
    HysteresisConfig,
)

# Initialize job router
self._job_router = GateJobRouter(
    coordinate_tracker=self._coordinate_tracker,
    get_datacenter_candidates=self._get_datacenter_candidates_for_router,
    config=GateJobRouterConfig(
        scoring_config=ScoringConfig(
            a_util=0.5,
            a_queue=0.3,
            a_cb=0.2,
            preference_multiplier=0.9,
        ),
        hysteresis_config=HysteresisConfig(
            hold_down_seconds=30.0,
            improvement_ratio=0.8,
            cooldown_seconds=60.0,
        ),
        max_primary_dcs=2,
        cooldown_penalty_multiplier=2.0,
    ),
)
```

### 8.4 Datacenter Candidates Callback

```python
def _get_datacenter_candidates_for_router(self) -> list[DatacenterCandidate]:
    """
    Build datacenter candidates for the router.
    
    Combines health classification with capacity metrics.
    """
    datacenter_ids = list(self._datacenter_managers.keys())
    candidates = self._health_coordinator.build_datacenter_candidates(datacenter_ids)
    
    # Enrich with blended latency if available
    for candidate in candidates:
        if self._blended_scorer:
            predicted_rtt = candidate.rtt_ucb_ms
            blended = self._blended_scorer.get_latency_for_scoring(
                datacenter_id=candidate.datacenter_id,
                predicted_rtt_ms=predicted_rtt,
                use_blending=True,
            )
            candidate.rtt_ucb_ms = blended
    
    return candidates
```

### 8.5 Replace Legacy Selection

```python
def _select_datacenters_with_fallback(
    self,
    count: int,
    preferred: list[str] | None = None,
    job_id: str | None = None,
) -> tuple[list[str], list[str], str]:
    """
    Select datacenters using the unified router.
    
    Falls back to legacy selection if router not available.
    """
    if self._job_router is None or job_id is None:
        return self._legacy_select_datacenters(count, preferred)
    
    # Use unified router
    decision = self._job_router.route_job(
        job_id=job_id,
        preferred_datacenters=set(preferred) if preferred else None,
    )
    
    # Map routing decision to legacy return format
    primary = decision.primary_datacenters[:count]
    fallback = (
        decision.primary_datacenters[count:] + 
        decision.fallback_datacenters
    )
    worst_health = decision.primary_bucket.lower() if decision.primary_bucket else "unhealthy"
    
    return (primary, fallback, worst_health)
```

### 8.6 Cleanup Integration

```python
async def _cleanup_single_job(self, job_id: str) -> None:
    """Clean up all state for a completed job."""
    # ... existing cleanup ...
    
    self._job_manager.delete_job(job_id)
    # ... other cleanup ...
    
    # Clean up routing state (AD-51)
    if self._job_router:
        self._job_router.cleanup_job_state(job_id)
    
    # Clean up dispatch time tracking
    await self._dispatch_time_tracker.remove_job(job_id)
```

### 8.7 Record Dispatch Failure

```python
async def _on_dispatch_failure(
    self,
    job_id: str,
    datacenter_id: str,
    error: Exception,
) -> None:
    """Record dispatch failure for cooldown penalty."""
    if self._job_router:
        self._job_router.record_dispatch_failure(job_id, datacenter_id)
```

---

## Part 9: Integration Checklist

### Prerequisites

- [x] `CoordinateTracker` implemented (`swim/coordinates/coordinate_tracker.py`)
- [x] `GateJobRouter` implemented (`routing/gate_job_router.py`)
- [x] `RoutingScorer` implemented (`routing/scoring.py`)
- [x] `CandidateFilter` implemented (`routing/candidate_filter.py`)
- [x] `HysteresisManager` implemented (`routing/hysteresis.py`)
- [x] `ObservedLatencyTracker` implemented (`routing/observed_latency_tracker.py`)
- [x] `BlendedLatencyScorer` implemented (`routing/blended_latency_scorer.py`)
- [x] `GateHealthCoordinator.build_datacenter_candidates()` implemented
- [x] `DatacenterCapacityAggregator` wired
- [x] `SpilloverEvaluator` wired

### Integration Steps

1. [ ] Add `CoordinateTracker` to `GateServer.__init__`
2. [ ] Wire coordinate updates on RTT measurements
3. [ ] Add `GateJobRouter` to `GateServer.__init__`
4. [ ] Create `_get_datacenter_candidates_for_router()` callback
5. [ ] Integrate `BlendedLatencyScorer` into candidate enrichment
6. [ ] Replace `_select_datacenters_with_fallback` to use router
7. [ ] Pass `job_id` through dispatch flow
8. [ ] Add `cleanup_job_state()` to `_cleanup_single_job`
9. [ ] Add `record_dispatch_failure()` on dispatch failures
10. [ ] Add logging and metrics

---

## Part 10: Observability

### Metrics

```python
# Routing decision metrics
routing_decisions_total{bucket, reason, switched}
routing_score{datacenter_id}
routing_score_component{datacenter_id, component}  # rtt, load, quality
routing_switch_total{reason}
routing_hold_down_blocks_total
routing_cooldown_applied_total{datacenter_id}

# Vivaldi metrics
vivaldi_coordinate_updates_total
vivaldi_prediction_error_ms{datacenter_id}
vivaldi_sample_count{datacenter_id}
vivaldi_convergence_state{converged}

# Blended latency metrics
blended_latency_ms{datacenter_id}
blended_latency_confidence{datacenter_id}
observed_latency_ewma_ms{datacenter_id}
```

### Logs

```python
# Routing decision log
ServerInfo(
    message=f"Routed job {job_id[:8]}... to {primary_dcs} "
            f"(bucket={bucket}, reason={reason}, switched={switched})"
)

# Hysteresis log
ServerDebug(
    message=f"Hysteresis: job {job_id[:8]}... retained {current_dc} "
            f"(hold_down={hold_down_remaining}s, improvement={improvement_ratio})"
)

# Cooldown log
ServerDebug(
    message=f"Applied cooldown penalty to {dc_id} for job {job_id[:8]}... "
            f"(expires_in={expires_in}s)"
)
```

---

## Part 11: Success Criteria

1. **Latency Reduction**: 50% lower median routing latency vs legacy
2. **Load Distribution**: Load variance coefficient < 0.3
3. **Routing Stability**: Switch rate < 1% of decisions (hysteresis working)
4. **Bootstrap Safety**: No routing failures during coordinate convergence
5. **Cleanup**: Zero routing state leaks (verified via metrics)
6. **Fallback**: Graceful degradation to legacy if router fails

---

## Part 12: Migration Strategy

### Phase 1: Shadow Mode
- Router runs in parallel with legacy
- Log decisions but don't act on them
- Compare results for validation

### Phase 2: Gradual Rollout
- Feature flag to enable router for % of jobs
- Monitor metrics and errors
- Increase percentage gradually

### Phase 3: Full Activation
- Router as primary path
- Legacy as fallback only
- Remove legacy after stability period

---

## Conclusion

AD-51 unifies the routing subsystem by connecting:
- **AD-35**: Vivaldi coordinates for RTT estimation
- **AD-36**: Multi-factor scoring and hysteresis
- **AD-45**: Observed latency learning
- **AD-43**: Capacity-aware spillover
- **AD-16/17**: Health bucket classification

The result is a routing system that is:
- **Latency-aware**: Uses real network topology
- **Adaptive**: Learns from actual job latencies
- **Stable**: Hysteresis prevents routing churn
- **Safe**: Bootstrap mode handles coordinate convergence
- **Clean**: Per-job state properly cleaned up
