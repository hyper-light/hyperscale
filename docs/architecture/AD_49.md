---
ad_number: 49
name: Workflow Context Propagation in Distributed Jobs
description: Enable context sharing between dependent workflows in distributed job execution
---

# AD-49: Workflow Context Propagation in Distributed Jobs

**Decision**: Implement workflow context propagation for distributed jobs by loading context from completed dependency workflows before dispatching dependent workflows. Context flows Worker -> Manager -> Dependent Workflow, with cross-manager sync via existing ContextLayerSync infrastructure.

**Related**: AD-48 (Cross-Manager Worker Visibility), AD-33 (Federated Health Monitoring), AD-38 (Global Job Ledger)

**Rationale**:
- Non-test workflows often provide context (via `@provide` hooks) that dependent workflows consume (via `@use` hooks)
- Local execution via `RemoteGraphManager` correctly propagates context between workflows
- Distributed execution via `WorkflowDispatcher` currently sends empty context `{}` to all workers
- This breaks the workflow dependency contract: dependent workflows cannot access data from their dependencies
- Existing infrastructure (`JobInfo.context`, `_apply_context_updates`, `ContextLayerSync`) supports context but isn't wired to dispatch

---

## Part 1: Architecture Overview

```
                        WORKFLOW CONTEXT PROPAGATION
                        
  ┌─────────────────────────────────────────────────────────────────────────┐
  │                           JOB EXECUTION                                  │
  │                                                                          │
  │  ┌─────────────────────────────────────────────────────────────────┐    │
  │  │                    WORKFLOW A (Setup)                           │    │
  │  │              is_test=False, provides: {api_token, session_id}   │    │
  │  └───────────────────────────┬─────────────────────────────────────┘    │
  │                              │                                           │
  │                              │ (1) WorkflowFinalResult                   │
  │                              │     context_updates: {api_token, session} │
  │                              ▼                                           │
  │  ┌─────────────────────────────────────────────────────────────────┐    │
  │  │                    MANAGER (Job Leader)                          │    │
  │  │                                                                  │    │
  │  │   JobInfo.context:                                              │    │
  │  │     workflow_a: {api_token: "xyz", session_id: "abc"}           │    │
  │  │     layer_version: 1                                            │    │
  │  │                                                                  │    │
  │  └───────────────────────────┬─────────────────────────────────────┘    │
  │                              │                                           │
  │                              │ (2) WorkflowDispatch                      │
  │                              │     context: {api_token, session_id}      │
  │                              │     context_version: 1                    │
  │                              ▼                                           │
  │  ┌─────────────────────────────────────────────────────────────────┐    │
  │  │                    WORKFLOW B (Test)                             │    │
  │  │              is_test=True, depends_on: [WorkflowA]               │    │
  │  │              uses: {api_token, session_id}                       │    │
  │  └─────────────────────────────────────────────────────────────────┘    │
  │                                                                          │
  └─────────────────────────────────────────────────────────────────────────┘
```

---

## Part 2: Comparison - Local vs Distributed Execution

| Aspect | RemoteGraphManager (Local) | WorkflowDispatcher (Distributed) - BEFORE | WorkflowDispatcher - AFTER |
|--------|---------------------------|------------------------------------------|---------------------------|
| Load context from deps | `_use_context()` | Always sends `{}` | `_get_context_for_workflow()` |
| Send context to workers | `loaded_context` | Empty dict | Loaded from `JobInfo.context` |
| Save context after completion | `_provide_context()` + `update_context()` | `_apply_context_updates()` | No change (already works) |
| Context flows between workflows | Yes | **No - broken** | Yes |

---

## Part 3: Context Flow Diagram

### Single Manager Case

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         SINGLE MANAGER CONTEXT FLOW                          │
└─────────────────────────────────────────────────────────────────────────────┘

  Worker₁                           Manager                           Worker₂
  (WorkflowA)                                                        (WorkflowB)
     │                                 │                                  │
     │ ══════════════════════════════════════════════════════════════════│
     │           PHASE 1: WorkflowA Execution & Context Capture          │
     │ ══════════════════════════════════════════════════════════════════│
     │                                 │                                  │
     │  (1) Execute WorkflowA          │                                  │
     │      @provide hooks run         │                                  │
     │      context = {token: "xyz"}   │                                  │
     │                                 │                                  │
     │  (2) WorkflowFinalResult        │                                  │
     │      context_updates: bytes     │                                  │
     │ ───────────────────────────────>│                                  │
     │                                 │                                  │
     │                    ┌────────────┴────────────┐                     │
     │                    │ _apply_context_updates  │                     │
     │                    │                         │                     │
     │                    │ job_contexts[job_id]    │                     │
     │                    │   [workflow_a]          │                     │
     │                    │     .update(key, value) │                     │
     │                    │                         │                     │
     │                    │ layer_version += 1      │                     │
     │                    └────────────┬────────────┘                     │
     │                                 │                                  │
     │                    ┌────────────┴────────────┐                     │
     │                    │ mark_workflow_completed │                     │
     │                    │                         │                     │
     │                    │ WorkflowB.completed_deps│                     │
     │                    │   .add(WorkflowA)       │                     │
     │                    │                         │                     │
     │                    │ check_and_signal_ready()│                     │
     │                    │ → WorkflowB is READY    │                     │
     │                    └────────────┬────────────┘                     │
     │                                 │                                  │
     │ ══════════════════════════════════════════════════════════════════│
     │           PHASE 2: WorkflowB Dispatch with Context                │
     │ ══════════════════════════════════════════════════════════════════│
     │                                 │                                  │
     │                    ┌────────────┴────────────┐                     │
     │                    │ _dispatch_workflow(B)   │                     │
     │                    │                         │                     │
     │                    │ context = _get_context_ │                     │
     │                    │   _for_workflow(        │                     │
     │                    │     job_id,             │                     │
     │                    │     "WorkflowB",        │                     │
     │                    │     deps={WorkflowA}    │                     │
     │                    │   )                     │                     │
     │                    │                         │                     │
     │                    │ → {token: "xyz"}        │                     │
     │                    └────────────┬────────────┘                     │
     │                                 │                                  │
     │                                 │  (3) WorkflowDispatch            │
     │                                 │      context: {token: "xyz"}     │
     │                                 │      context_version: 1          │
     │                                 │ ─────────────────────────────────>
     │                                 │                                  │
     │                                 │                     (4) Execute  │
     │                                 │                         @use     │
     │                                 │                         hooks    │
     │                                 │                         access   │
     │                                 │                         context  │
     │                                 │                                  │
```

### Multi-Manager Case

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         MULTI-MANAGER CONTEXT FLOW                           │
└─────────────────────────────────────────────────────────────────────────────┘

  Worker₁         Manager₁           Manager₂          Manager₃         Worker₂
  (on Mgr₁)     (non-leader)       (job leader)      (non-leader)      (on Mgr₃)
     │               │                   │                 │               │
     │ ═══════════════════════════════════════════════════════════════════│
     │           PHASE 1: WorkflowA completes on Manager₁'s worker        │
     │ ═══════════════════════════════════════════════════════════════════│
     │               │                   │                 │               │
     │ WorkflowFinal │                   │                 │               │
     │ Result        │                   │                 │               │
     │ ─────────────>│                   │                 │               │
     │               │                   │                 │               │
     │               │ ContextForward    │                 │               │
     │               │ {job_id,          │                 │               │
     │               │  workflow_id,     │                 │               │
     │               │  context_updates} │                 │               │
     │               │ ─────────────────>│                 │               │
     │               │                   │                 │               │
     │               │                   │ Apply updates   │               │
     │               │                   │ Increment       │               │
     │               │                   │ layer_version   │               │
     │               │                   │                 │               │
     │ ═══════════════════════════════════════════════════════════════════│
     │           PHASE 2: WorkflowB ready, dispatches from Manager₃       │
     │ ═══════════════════════════════════════════════════════════════════│
     │               │                   │                 │               │
     │               │                   │                 │ WorkflowB     │
     │               │                   │                 │ ready,        │
     │               │                   │                 │ needs context │
     │               │                   │                 │               │
     │               │                   │                 │ Check local   │
     │               │                   │                 │ layer_version │
     │               │                   │                 │               │
     │               │                   │ ContextLayerSync│               │
     │               │                   │ {context_snapshot│              │
     │               │                   │  layer_version} │               │
     │               │                   │ ───────────────>│               │
     │               │                   │                 │               │
     │               │                   │                 │ Apply context │
     │               │                   │                 │ Update        │
     │               │                   │                 │ layer_version │
     │               │                   │                 │               │
     │               │                   │                 │ Dispatch      │
     │               │                   │                 │ WorkflowB     │
     │               │                   │                 │ with context  │
     │               │                   │                 │ ─────────────>│
     │               │                   │                 │               │
```

---

## Part 4: State Machine - Context Layer Version

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    CONTEXT LAYER VERSION STATE MACHINE                       │
└─────────────────────────────────────────────────────────────────────────────┘

                              Job Leader                    Follower Manager
                              
                         ┌─────────────┐                  ┌─────────────┐
                         │  Version 0  │                  │  Version 0  │
                         │  (no ctx)   │                  │  (no ctx)   │
                         └──────┬──────┘                  └──────┬──────┘
                                │                                │
                   WorkflowA completes                          │
                   context_updates received                     │
                                │                                │
                                ▼                                │
                         ┌─────────────┐                         │
                         │  Version 1  │                         │
                         │  ctx: {A}   │                         │
                         └──────┬──────┘                         │
                                │                                │
                   ContextLayerSync ─────────────────────────────>
                                │                                │
                                │                                ▼
                                │                         ┌─────────────┐
                                │                         │  Version 1  │
                                │                         │  ctx: {A}   │
                                │                         └──────┬──────┘
                                │                                │
                   WorkflowB completes                          │
                   context_updates received                     │
                                │                                │
                                ▼                                │
                         ┌─────────────┐                         │
                         │  Version 2  │                         │
                         │  ctx: {A,B} │                         │
                         └──────┬──────┘                         │
                                │                                │
                   ContextLayerSync ─────────────────────────────>
                                │                                │
                                │                                ▼
                                │                         ┌─────────────┐
                                │                         │  Version 2  │
                                │                         │  ctx: {A,B} │
                                │                         └─────────────┘
```

---

## Part 5: Failure Mode Handling

### Failure Mode 1: Context Update Lost (Worker -> Manager)

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    FAILURE: Context Update Lost                              │
└─────────────────────────────────────────────────────────────────────────────┘

  Worker                              Manager
     │                                   │
     │  WorkflowFinalResult              │
     │  {context_updates: {token: xyz}}  │
     │ ─────────────────────────────────X│  ← Network failure
     │                                   │
     │  [No ACK received]                │
     │                                   │
     │  Retry (existing retry logic)     │
     │  WorkflowFinalResult              │
     │ ─────────────────────────────────>│
     │                                   │
     │                      ACK          │
     │ <─────────────────────────────────│
     │                                   │

RECOVERY: WorkflowFinalResult delivery uses existing retry logic.
          Context updates are idempotent (LWW with timestamps).
          
IMPACT: Dependent workflows delayed until context arrives.
        No data loss - retry ensures eventual delivery.
```

### Failure Mode 2: Manager Crashes Before Context Sync

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    FAILURE: Job Leader Crashes                               │
└─────────────────────────────────────────────────────────────────────────────┘

  Manager₁ (leader)              Manager₂ (follower)           Manager₃
        │                               │                          │
        │  Context: {A: {token: xyz}}   │                          │
        │  layer_version: 1             │                          │
        │                               │                          │
        X ← CRASH                       │                          │
                                        │                          │
                          Leader election triggered                │
                                        │                          │
                                        │ Becomes new leader       │
                                        │ layer_version: 0         │
                                        │ Context: {} (stale)      │
                                        │                          │
                                        │ Dispatch WorkflowB       │
                                        │ context: {} (incomplete) │
                                        │ ─────────────────────────>
                                        │                          │

RECOVERY: Context is NOT critical data - workflow can still execute.
          WorkflowB will have empty context for dependencies.
          
ACCEPTABLE BECAUSE:
  1. Context is convenience data, not correctness requirement
  2. Workflow can check for missing context and handle gracefully
  3. Alternative would require WAL for context (too expensive)
  
MITIGATION: 
  - Leader syncs context to followers periodically (not just on update)
  - Dependent workflow can request context re-sync if version mismatch
```

### Failure Mode 3: Context Sync Fails (Leader -> Follower)

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    FAILURE: ContextLayerSync Fails                           │
└─────────────────────────────────────────────────────────────────────────────┘

  Manager₁ (leader)              Manager₂ (follower)
        │                               │
        │  ContextLayerSync             │
        │  {version: 1, snapshot: ...}  │
        │ ─────────────────────────────X│  ← Network partition
        │                               │
        │  [No ACK / timeout]           │
        │                               │
        │  Retry with backoff           │
        │  ContextLayerSync             │
        │ ─────────────────────────────>│
        │                               │
        │                      ACK      │
        │ <─────────────────────────────│
        │                               │

RECOVERY: Leader retries ContextLayerSync with exponential backoff.
          Follower accepts sync if version > local version.
          
GOSSIP FALLBACK: If TCP sync fails repeatedly, context will eventually
                 propagate via steady-state gossip piggyback (slower).
```

### Failure Mode 4: Stale Context Dispatch

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    FAILURE: Workflow Dispatched with Stale Context           │
└─────────────────────────────────────────────────────────────────────────────┘

  Manager₁ (leader)              Manager₂ (follower)           Worker
        │                               │                         │
        │  layer_version: 2             │                         │
        │                               │                         │
        │                               │ layer_version: 1        │
        │                               │ (missed sync)           │
        │                               │                         │
        │                               │ Dispatch WorkflowC      │
        │                               │ context_version: 1      │
        │                               │ ────────────────────────>
        │                               │                         │
        │                               │          WorkflowC runs │
        │                               │          with partial   │
        │                               │          context        │
        │                               │                         │

DETECTION: Worker can compare context_version in dispatch vs expected.
           If mismatch, worker logs warning but continues execution.
           
RECOVERY: Not automatic - context propagation is best-effort.
          Next workflow dispatch will request fresh context sync.
          
ACCEPTABLE BECAUSE: Context is convenience, not correctness.
```

---

## Part 6: Network Diagram - Context Message Types

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         CONTEXT MESSAGE TYPES                                │
└─────────────────────────────────────────────────────────────────────────────┘

                    ┌─────────────────────────────────────────┐
                    │            MESSAGE TYPES                 │
                    └─────────────────────────────────────────┘

  ┌─────────────────────────────────────────────────────────────────────────┐
  │ WorkflowFinalResult (Worker → Manager)                                   │
  │ ─────────────────────────────────────────────────────────────────────── │
  │ Direction: Worker → Manager that dispatched the workflow                 │
  │ Protocol:  TCP (reliable delivery required)                              │
  │ Size:      Variable (context_updates can be large)                       │
  │                                                                          │
  │ Fields:                                                                  │
  │   job_id: str                                                           │
  │   workflow_id: str                                                      │
  │   workflow_name: str                                                    │
  │   status: str                                                           │
  │   results: bytes              # Workflow execution results              │
  │   context_updates: bytes      # Cloudpickled dict of context changes    │
  │   error: str | None                                                     │
  │   worker_id: str                                                        │
  │   worker_available_cores: int                                           │
  └─────────────────────────────────────────────────────────────────────────┘

  ┌─────────────────────────────────────────────────────────────────────────┐
  │ ContextForward (Non-leader Manager → Job Leader)                         │
  │ ─────────────────────────────────────────────────────────────────────── │
  │ Direction: Non-leader manager → Job leader manager                       │
  │ Protocol:  TCP (reliable delivery required)                              │
  │ Size:      Variable (forwards context_updates from worker)               │
  │                                                                          │
  │ Fields:                                                                  │
  │   job_id: str                                                           │
  │   workflow_id: str                                                      │
  │   context_updates: bytes      # Cloudpickled dict                       │
  │   context_timestamps: bytes   # Cloudpickled timestamps for LWW         │
  └─────────────────────────────────────────────────────────────────────────┘

  ┌─────────────────────────────────────────────────────────────────────────┐
  │ ContextLayerSync (Job Leader → Followers)                                │
  │ ─────────────────────────────────────────────────────────────────────── │
  │ Direction: Job leader → All follower managers                            │
  │ Protocol:  TCP (reliable delivery required)                              │
  │ Size:      Potentially large (full context snapshot)                     │
  │                                                                          │
  │ Fields:                                                                  │
  │   job_id: str                                                           │
  │   layer_version: int          # Monotonic version for staleness check   │
  │   context_snapshot: bytes     # Full cloudpickled context               │
  │   source_node_id: str         # Leader node ID                          │
  └─────────────────────────────────────────────────────────────────────────┘

  ┌─────────────────────────────────────────────────────────────────────────┐
  │ WorkflowDispatch (Manager → Worker)                                      │
  │ ─────────────────────────────────────────────────────────────────────── │
  │ Direction: Manager → Worker                                              │
  │ Protocol:  TCP (reliable delivery required)                              │
  │ Size:      Variable (workflow + context)                                 │
  │                                                                          │
  │ Fields:                                                                  │
  │   job_id: str                                                           │
  │   workflow_id: str                                                      │
  │   workflow: bytes             # Cloudpickled workflow                   │
  │   context: bytes              # Cloudpickled context for dependencies   │
  │   vus: int                                                              │
  │   cores: int                                                            │
  │   timeout_seconds: float                                                │
  │   fence_token: int                                                      │
  │   context_version: int        # Layer version for staleness detection   │
  └─────────────────────────────────────────────────────────────────────────┘
```

---

## Part 7: Implementation Guide

### Step 1: Add Context Access Methods to JobManager

```python
# hyperscale/distributed/jobs/job_manager.py

class JobManager:
    """Manages job state and tracking."""
    
    async def get_job_context(self, job_id: str) -> Context | None:
        """
        Get context for a job.
        
        Returns the job's Context object containing all workflow contexts,
        or None if job not found.
        """
        job_info = self._jobs.get(job_id)
        if job_info is None:
            return None
        
        async with job_info.lock:
            return job_info.context
    
    async def get_layer_version(self, job_id: str) -> int:
        """
        Get current context layer version for a job.
        
        Layer version increments each time context is updated.
        Used for staleness detection in cross-manager sync.
        """
        job_info = self._jobs.get(job_id)
        if job_info is None:
            return 0
        
        async with job_info.lock:
            return job_info.layer_version
    
    async def increment_layer_version(self, job_id: str) -> int:
        """
        Increment and return new layer version after context update.
        
        Called after _apply_context_updates to signal new context available.
        """
        job_info = self._jobs.get(job_id)
        if job_info is None:
            return 0
        
        async with job_info.lock:
            job_info.layer_version += 1
            return job_info.layer_version
    
    async def get_context_for_workflow(
        self,
        job_id: str,
        workflow_name: str,
        dependencies: set[str],
    ) -> dict[str, Any]:
        """
        Get context values from completed dependency workflows.
        
        Collects context from all workflows this workflow depends on.
        Returns empty dict if no context or dependencies not found.
        
        Args:
            job_id: The job ID
            workflow_name: Name of the workflow being dispatched
            dependencies: Set of workflow names this workflow depends on
            
        Returns:
            Dict of {key: value} from all dependency workflow contexts
        """
        job_info = self._jobs.get(job_id)
        if job_info is None:
            return {}
        
        async with job_info.lock:
            context_for_workflow: dict[str, Any] = {}
            
            for dep_name in dependencies:
                if dep_name in job_info.context:
                    dep_context = job_info.context[dep_name]
                    for key, value in dep_context.items():
                        context_for_workflow[key] = value
            
            return context_for_workflow
```

### Step 2: Modify WorkflowDispatcher to Load Context

```python
# hyperscale/distributed/jobs/workflow_dispatcher.py

import zlib

# Add compression threshold constant
CONTEXT_COMPRESSION_THRESHOLD = 1024  # Compress if > 1KB


def _serialize_context(context_dict: dict) -> bytes:
    """
    Serialize and optionally compress context for transmission.
    
    Compresses payloads > 1KB to reduce network overhead for
    large context values.
    """
    pickled = cloudpickle.dumps(context_dict)
    if len(pickled) > CONTEXT_COMPRESSION_THRESHOLD:
        compressed = zlib.compress(pickled, level=6)
        # Prefix with marker byte to indicate compression
        return b'\x01' + compressed
    # Prefix with marker byte to indicate no compression
    return b'\x00' + pickled


class WorkflowDispatcher:
    """Manages workflow dispatch to workers."""
    
    async def _dispatch_workflow(
        self,
        pending: PendingWorkflow,
        submission: JobSubmission,
        cores_needed: int,
    ) -> bool:
        """
        Dispatch a single workflow to workers.
        
        Loads context from completed dependencies before dispatch (AD-49).
        """
        # ... existing validation and retry logic ...
        
        # AD-49: Load context from completed dependencies
        context_for_workflow = await self._job_manager.get_context_for_workflow(
            pending.job_id,
            pending.workflow_name,
            pending.dependencies,
        )
        
        # Serialize with optional compression
        context_bytes = _serialize_context(context_for_workflow)
        
        # Get current layer version for staleness detection
        layer_version = await self._job_manager.get_layer_version(pending.job_id)
        
        # ... rest of dispatch logic uses context_bytes and layer_version ...
```

### Step 3: Update WorkflowDispatch Context Handling

The `WorkflowDispatch` message already has `context` and `context_version` fields:

```python
# hyperscale/distributed/models/distributed.py (existing)

@dataclass(slots=True)
class WorkflowDispatch(Message):
    """Dispatch a workflow to a worker."""
    job_id: str
    workflow_id: str
    workflow: bytes
    context: bytes          # AD-49: Now populated with dependency context
    vus: int
    cores: int
    timeout_seconds: float
    fence_token: int
    context_version: int    # AD-49: Layer version for staleness detection
```

### Step 4: Worker Deserializes Context

```python
# hyperscale/distributed/models/distributed.py

def _deserialize_context(data: bytes) -> dict:
    """
    Deserialize context, handling compression.
    
    Checks prefix byte to determine if decompression needed.
    """
    if len(data) == 0:
        return {}
    
    marker = data[0:1]
    payload = data[1:]
    
    if marker == b'\x01':
        # Compressed
        decompressed = zlib.decompress(payload)
        return cloudpickle.loads(decompressed)
    else:
        # Not compressed
        return cloudpickle.loads(payload)


@dataclass(slots=True)
class WorkflowDispatch(Message):
    """Dispatch a workflow to a worker."""
    # ... existing fields ...
    
    def load_context(self) -> dict:
        """Load and deserialize context dict."""
        return _deserialize_context(self.context)
```

---

## Part 8: Integration Points

### 8.1 WorkflowDispatcher._dispatch_workflow() Changes

**Location**: `hyperscale/distributed/jobs/workflow_dispatcher.py`, lines 591-593

**Before**:
```python
# Serialize workflow
workflow_bytes = cloudpickle.dumps(pending.workflow)
context_bytes = cloudpickle.dumps({})  # ALWAYS EMPTY
```

**After**:
```python
# Serialize workflow
workflow_bytes = cloudpickle.dumps(pending.workflow)

# AD-49: Load context from completed dependencies
context_for_workflow = await self._job_manager.get_context_for_workflow(
    pending.job_id,
    pending.workflow_name,
    pending.dependencies,
)
context_bytes = _serialize_context(context_for_workflow)

# Get layer version for staleness detection
layer_version = await self._job_manager.get_layer_version(pending.job_id)
```

### 8.2 WorkflowDispatch Creation

**Location**: `hyperscale/distributed/jobs/workflow_dispatcher.py`, lines 620-631

**Before**:
```python
dispatch = WorkflowDispatch(
    job_id=pending.job_id,
    workflow_id=str(sub_token),
    workflow=workflow_bytes,
    context=context_bytes,
    vus=worker_vus,
    cores=worker_cores,
    timeout_seconds=submission.timeout_seconds,
    fence_token=fence_token,
    context_version=0,  # ALWAYS 0
)
```

**After**:
```python
dispatch = WorkflowDispatch(
    job_id=pending.job_id,
    workflow_id=str(sub_token),
    workflow=workflow_bytes,
    context=context_bytes,  # AD-49: Contains dependency context
    vus=worker_vus,
    cores=worker_cores,
    timeout_seconds=submission.timeout_seconds,
    fence_token=fence_token,
    context_version=layer_version,  # AD-49: Current layer version
)
```

### 8.3 Worker Context Loading

**Location**: `hyperscale/distributed/nodes/worker/workflow_executor.py`, line 258

**Existing** (already correct):
```python
context_dict = dispatch.load_context()
```

The worker already calls `load_context()` - it just receives empty dict. With AD-49, it will receive actual context.

---

## Part 9: Files Modified

| File | Change |
|------|--------|
| `hyperscale/distributed/jobs/job_manager.py` | Add `get_context_for_workflow()`, `get_layer_version()` methods |
| `hyperscale/distributed/jobs/workflow_dispatcher.py` | Load context before dispatch, add `_serialize_context()` |
| `hyperscale/distributed/models/distributed.py` | Add `_deserialize_context()` with compression support |
| `docs/architecture/AD_49.md` | This document |

---

## Part 10: Configuration

No new configuration required. Context propagation uses existing infrastructure:

| Setting | Location | Purpose |
|---------|----------|---------|
| `CONTEXT_COMPRESSION_THRESHOLD` | `workflow_dispatcher.py` | Compress context > 1KB (default) |

---

## Part 11: Observability

### Logging

```python
# In _dispatch_workflow()
await self._log_debug(
    f"Loaded context from {len(pending.dependencies)} dependencies: {len(context_for_workflow)} keys, {len(context_bytes)} bytes",
    job_id=pending.job_id,
    workflow_id=pending.workflow_id,
)
```

### Metrics (Future)

```python
# Potential metrics
context_load_duration_ms      # Time to load context from dependencies
context_size_bytes            # Size of serialized context
context_compression_ratio     # Compression effectiveness
context_version_mismatches    # Staleness detection hits
```

---

## Part 12: Testing Strategy

### Unit Tests

1. **Context serialization**: Verify `_serialize_context` / `_deserialize_context` roundtrip
2. **Compression threshold**: Verify small payloads not compressed, large payloads compressed
3. **JobManager.get_context_for_workflow**: Verify correct context collection from dependencies
4. **Layer version tracking**: Verify version increments on context update

### Integration Tests

1. **Single manager context flow**: WorkflowA provides, WorkflowB consumes
2. **Multi-manager context flow**: Context propagates via ContextLayerSync
3. **Empty dependencies**: Workflow with no dependencies gets empty context
4. **Large context**: Verify compression/decompression for large payloads

### Failure Tests

1. **Context update lost**: Verify retry delivers context eventually
2. **Stale context**: Verify workflow executes with stale context (degraded, not failed)
3. **Job leader crash**: Verify new leader can dispatch (with potentially stale context)

---

## Part 13: Anti-Patterns to Avoid

**DO NOT**:

```python
# Block on context sync before dispatch
await self._ensure_context_fully_synced()  # WRONG - adds latency

# Require context for dispatch
if not context_for_workflow:
    return False  # WRONG - context is optional, not required

# Store context in gossip buffer
self._gossip_buffer.add(context_update)  # WRONG - too large for gossip

# Use pickle instead of cloudpickle
pickle.dumps(context)  # WRONG - can't handle lambdas/closures
```

**DO**:

```python
# Best-effort context loading (non-blocking)
context_for_workflow = await self._job_manager.get_context_for_workflow(...)

# Dispatch proceeds even with empty context
context_bytes = _serialize_context(context_for_workflow)  # Empty is valid

# Use TCP for context sync (reliable, handles large payloads)
await self._send_tcp(peer, "context_layer_sync", sync_message)

# Use cloudpickle for arbitrary Python objects
cloudpickle.dumps(context)
```

---

## Part 14: Relationship to Other ADs

| AD | Relationship |
|----|--------------|
| AD-33 | FederatedHealthMonitor uses similar probe/ack pattern |
| AD-38 | Global Job Ledger provides durability; context is non-durable |
| AD-48 | Worker visibility uses same gossip infrastructure (but context doesn't piggyback) |
| AD-47 | Worker event log can record context mismatches for debugging |

---

## Part 15: Future Enhancements

1. **Context request/pull**: Worker can request missing context from manager
2. **Partial context sync**: Only sync changed keys, not full snapshot
3. **Context TTL**: Expire stale context after configurable duration
4. **Context metrics**: Track context size, propagation latency, compression ratio
