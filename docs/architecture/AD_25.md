---
ad_number: 25
name: Version Skew Handling
description: Protocol versioning and capability negotiation for zero-downtime rolling upgrades
---

# AD-25: Version Skew Handling

**Decision**: Support rolling upgrades via protocol versioning and capability negotiation.

**Rationale**:
- Zero-downtime upgrades require version compatibility
- Nodes must handle messages from older/newer versions
- Unknown fields should be ignored, not rejected
- Capability advertisement enables gradual feature rollout

**Protocol Versioning**:
```
┌─────────────────────────────────────────────────────────────────┐
│                    Version Skew Handling                        │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Version Format: MAJOR.MINOR                                    │
│  ├─ MAJOR: Breaking changes (must match)                       │
│  └─ MINOR: Additive changes (newer can talk to older)          │
│                                                                 │
│  Handshake includes:                                            │
│  ├─ protocol_version: "1.2"                                    │
│  ├─ capabilities: ["cancellation", "batched_stats", ...]       │
│  └─ node_version: "hyperscale-0.5.0" (informational)           │
│                                                                 │
│  Compatibility Rules:                                           │
│  ├─ Same MAJOR: compatible                                     │
│  ├─ Different MAJOR: reject connection                         │
│  ├─ Newer MINOR → older: use older's feature set               │
│  └─ Older MINOR → newer: newer ignores unknown capabilities    │
│                                                                 │
│  Message Handling:                                              │
│  ├─ Unknown fields: ignore (forward compatibility)             │
│  ├─ Missing optional fields: use defaults                      │
│  └─ Missing required fields: reject with clear error           │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**Implementation**:
```python
@dataclass
class ProtocolVersion:
    major: int
    minor: int

    def is_compatible_with(self, other: "ProtocolVersion") -> bool:
        return self.major == other.major

    def supports_feature(self, other: "ProtocolVersion", feature: str) -> bool:
        """Check if feature is supported by both versions."""
        # Feature was added in version X.Y
        feature_versions = {
            "cancellation": (1, 0),
            "batched_stats": (1, 1),
            "client_reconnection": (1, 2),
            "fence_tokens": (1, 2),
        }
        required = feature_versions.get(feature, (999, 999))
        return (
            (self.major, self.minor) >= required
            and (other.major, other.minor) >= required
        )

@dataclass
class NodeCapabilities:
    protocol_version: ProtocolVersion
    capabilities: set[str]
    node_version: str  # Informational

    def negotiate(self, other: "NodeCapabilities") -> set[str]:
        """Return capabilities supported by both nodes."""
        return self.capabilities & other.capabilities
```
