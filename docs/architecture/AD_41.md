---
ad_number: 41
name: Resource Guards - CPU/Memory Monitoring and Enforcement
description: Kalman-filtered resource monitoring with process tree tracking and graduated enforcement for workflow protection.
---

# AD-41: Resource Guards - CPU/Memory Monitoring and Enforcement

## Part 1: Problem Statement and Requirements

### The Resource Exhaustion Problem

In a distributed performance testing framework, workflows executing on workers can consume unbounded resources:

1. **Runaway workflows** - Bugs causing infinite loops or memory leaks
2. **Misconfigured jobs** - Users requesting more resources than allocated
3. **Cascading failures** - One overloaded worker destabilizing the cluster
4. **Invisible degradation** - No visibility into actual vs expected resource usage

Without resource guards, a single misbehaving workflow can:
- Exhaust worker memory, causing OOM kills
- Saturate worker CPU, starving other workflows
- Propagate back-pressure through the entire system
- Provide no signal to operators until catastrophic failure

### Requirements

1. **Accurate Monitoring**: CPU/memory usage tracked across entire process trees (workflows may spawn subprocesses)
2. **Low Overhead**: Monitoring must not significantly impact workflow performance
3. **Asyncio Compatible**: All monitoring must be non-blocking and work with asyncio event loops
4. **Hierarchical Aggregation**: Workers -> Managers -> Gates, with accurate cluster-wide totals
5. **Multi-Node Topology**: Handle multiple managers per datacenter, multiple gates per datacenter
6. **Noise Reduction**: Filter measurement noise without hiding real violations
7. **Uncertainty Quantification**: Know confidence in measurements for smarter decisions
8. **Graduated Enforcement**: WARN -> THROTTLE -> KILL progression with grace periods
9. **Pure Python**: pip-installable, no custom C code or eBPF

---

## Part 2: Kalman Filtering for Resource Metrics

### Why Kalman Filtering Instead of EWMA?

Resource metrics from `psutil` are inherently noisy due to:
- Context switches during sampling
- Kernel scheduling jitter
- GC pauses in monitored processes
- Subprocess spawn/exit timing

EWMA (Exponentially Weighted Moving Average) has limitations:
1. Fixed gain - cannot adapt to changing noise conditions
2. No uncertainty estimate - just a point value
3. Lag vs noise tradeoff - low alpha = smooth but laggy
4. Cannot model dynamics - assumes random walk

**Kalman Filter Advantages**:
1. Adaptive gain - automatically balances responsiveness vs smoothing
2. Uncertainty estimate - know confidence in each measurement
3. Optimal filtering - minimizes mean squared error
4. Can extend to model dynamics (acceleration, trends)

### Implementation

The `ScalarKalmanFilter` and `AdaptiveKalmanFilter` classes provide:
- Process noise (Q): variance in true value change
- Measurement noise (R): variance in psutil readings
- Automatic noise adaptation based on innovation sequence

---

## Part 3: Process Tree Resource Monitoring

### Design Rationale

Workflows may spawn subprocesses (e.g., browser automation, external tools). We must monitor the entire process tree, not just the root process.

**Key Implementation**:
- Uses `psutil.Process.children(recursive=True)` to traverse entire tree
- Aggregates CPU/memory across all descendants
- Handles subprocess spawn/exit dynamically
- Uses `asyncio.to_thread` for non-blocking psutil calls

### ResourceMetrics

The `ResourceMetrics` dataclass captures:
- `cpu_percent` and `cpu_uncertainty`
- `memory_bytes` and `memory_uncertainty`
- `memory_percent`
- `file_descriptor_count`
- `timestamp_monotonic` and `sample_count`
- `process_count` (live processes in tree)

---

## Part 4: Hierarchical Aggregation Architecture

### Multi-Node Topology

Each datacenter has multiple managers and multiple gates:

```
GATE CLUSTER (3 gates)
    │
    ├── gossip between gates
    │
    └── ManagerClusterResourceView (from any manager)
            │
MANAGER CLUSTER (4 managers)
    │
    ├── gossip between managers (LocalView sharing)
    │
    └── WorkerResourceReport (in heartbeat)
            │
WORKERS (N per manager)
    │
    └── Per-workflow Kalman-filtered metrics
```

### Manager Resource Gossip

Every manager maintains:
1. **LocalView** (computed locally): self metrics + worker aggregate
2. **Peer Views** (received via gossip): other managers' LocalViews
3. **ClusterView** (aggregated): all managers + all workers

Gossip runs every 2-5 seconds with 2-3 random peer views for faster propagation.

---

## Part 5: Graduated Enforcement

### Enforcement Levels

| Level | Trigger | Action |
|-------|---------|--------|
| WARN | 70% of budget | Log warning, emit metric |
| THROTTLE | 85% of budget | Reduce workflow throughput |
| KILL | 100% of budget | SIGTERM -> SIGKILL workflow |

### Grace Periods

- Violations must be sustained for configurable duration before action
- Prevents killing workflows on transient spikes
- Uncertainty-aware: high uncertainty + near threshold -> wait for more samples

---

## Part 6: Environment Configuration

```python
# Resource Guard Settings (AD-41)
RESOURCE_GUARD_ENABLED: bool = True
RESOURCE_GUARD_SAMPLE_INTERVAL_SECONDS: float = 1.0
RESOURCE_GUARD_WARN_THRESHOLD: float = 0.7
RESOURCE_GUARD_THROTTLE_THRESHOLD: float = 0.85
RESOURCE_GUARD_KILL_THRESHOLD: float = 1.0
RESOURCE_GUARD_GRACE_PERIOD_SECONDS: float = 5.0
RESOURCE_GUARD_KALMAN_PROCESS_NOISE: float = 10.0
RESOURCE_GUARD_KALMAN_MEASUREMENT_NOISE: float = 25.0
```
