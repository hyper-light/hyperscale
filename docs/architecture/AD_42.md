---
ad_number: 42
name: SLO-Aware Health and Routing
description: T-Digest streaming percentiles with SWIM hierarchy integration for latency SLO tracking and routing.
---

# AD-42: SLO-Aware Health and Routing

**Related**: AD-16 (Datacenter Health Classification), AD-35 (Vivaldi Coordinates), AD-36 (Datacenter Routing), AD-41 (Resource Guards)

---

## Part 1: Problem Statement

### The Latency Visibility Gap

Current routing uses RTT estimation (AD-35 Vivaldi) and load factors (AD-36) but lacks visibility into actual application-level latency SLOs:

| What We Have | What We Need |
|--------------|--------------|
| Vivaldi RTT (network round-trip) | Application latency (dispatch -> response) |
| Point estimate + uncertainty | p50, p95, p99 percentiles |
| Load factor (queue depth, CPU) | SLO compliance scoring |
| Binary health (healthy/degraded) | Continuous: meeting/warning/violating/critical |

**Consequence**: A DC may report healthy RTT and load while actual p95 latency violates SLO targets.

### Requirements

1. **Streaming Percentiles**: Track p50, p95, p99 without storing all samples
2. **Memory Bounded**: O(delta) memory regardless of sample count
3. **Mergeable**: Combine percentile sketches across SWIM tiers
4. **Time Windowed**: Only consider recent data (last 5 minutes)
5. **SLO Definition**: Configurable latency targets per-job or global
6. **Routing Integration**: SLO factor in AD-36 scoring formula
7. **Health Integration**: SLO signal informs AD-16 health classification
8. **Resource Correlation**: AD-41 resource pressure predicts latency (proactive)
9. **SWIM Distribution**: Data flows through existing SWIM gossip hierarchy
10. **Pure Python**: pip-installable, asyncio-compatible

---

## Part 2: Architecture - T-Digest Selection

After evaluating streaming percentile algorithms:

| Algorithm | Weakness | T-Digest Advantage |
|-----------|----------|-------------------|
| HDR Histogram | Fixed range required | Dynamic range, no pre-configuration |
| P2 Algorithm | Single quantile at a time | All quantiles, mergeable across nodes |
| Sorted buffer | O(n) memory unbounded | O(delta) memory, ~100 centroids |
| Random sampling | Tail inaccuracy | Tail-optimized (p99, p99.9) |

**T-Digest Properties**:
- Constant memory: O(delta) where delta controls accuracy (~100 centroids)
- Accuracy: ~0.1% at tails (p99, p99.9), ~1% at median
- Mergeable: Can combine digests from multiple SWIM nodes
- Streaming: Update in O(1) amortized

---

## Part 3: SWIM Hierarchy for SLO Data

SLO data flows through the existing 3-tier SWIM hierarchy, piggybacked on heartbeats:

### Tier 1: Workers <-> Managers (per datacenter)
- Workers send `latency_samples` and `latency_digest_delta` in heartbeats
- Managers merge worker digests via gossip

### Tier 2: Managers -> Gates (TCP, cross-datacenter)
- Managers send DC-level SLO summary in ManagerHeartbeat
- Includes `dc_slo_health` classification

### Tier 3: Gates <-> Gates (SWIM)
- Gates gossip `dc_slo_summaries` across all DCs
- Each gate maintains cluster-wide SLO view

---

## Part 4: Compact SLO Gossip Payloads

To minimize gossip overhead (~32 bytes vs ~1.6KB full T-Digest):

```python
@dataclass(slots=True)
class SLOSummary:
    """Compact SLO summary for SWIM gossip (~32 bytes)."""
    p50_ms: float
    p95_ms: float
    p99_ms: float
    sample_count: int
    compliance_score: float  # Pre-computed
    routing_factor: float    # For AD-36 scoring
    updated_at: float
```

### Hierarchical State

1. **LOCAL STATE** (Full Fidelity): Job owner maintains full T-Digest
2. **GOSSIP STATE** (Compact): SLOSummary piggybacked in heartbeats
3. **MERGED STATE** (Cluster-Wide): Each node merges peer summaries

---

## Part 5: SLO Compliance Scoring

### Compliance Levels

| Level | Description |
|-------|-------------|
| EXCEEDING | Well below targets (bonus) |
| MEETING | At or below targets |
| WARNING | Approaching targets (80-100%) |
| VIOLATING | Above targets (100-150%) |
| CRITICAL | Severely above targets (>150%) |

### Health Classification Thresholds

- `SLO_BUSY_P50_RATIO: 1.5` - p50 at 1.5x target -> BUSY
- `SLO_DEGRADED_P95_RATIO: 2.0` - p95 at 2x target -> DEGRADED
- `SLO_DEGRADED_P99_RATIO: 3.0` - p99 at 3x target -> DEGRADED
- `SLO_UNHEALTHY_P99_RATIO: 5.0` - p99 at 5x target -> UNHEALTHY

---

## Part 6: Environment Configuration

```python
# SLO-Aware Routing Settings (AD-42)
SLO_TDIGEST_DELTA: float = 100.0
SLO_TDIGEST_MAX_UNMERGED: int = 2048
SLO_WINDOW_DURATION_SECONDS: float = 60.0
SLO_MAX_WINDOWS: int = 5
SLO_EVALUATION_WINDOW_SECONDS: float = 300.0

# Default SLO targets
SLO_P50_TARGET_MS: float = 50.0
SLO_P95_TARGET_MS: float = 200.0
SLO_P99_TARGET_MS: float = 500.0

# SLO weight distribution
SLO_P50_WEIGHT: float = 0.2
SLO_P95_WEIGHT: float = 0.5
SLO_P99_WEIGHT: float = 0.3

# Routing integration
SLO_FACTOR_MIN: float = 0.5
SLO_FACTOR_MAX: float = 3.0
SLO_SCORE_WEIGHT: float = 0.4

# Resource correlation (AD-41 integration)
SLO_ENABLE_RESOURCE_PREDICTION: bool = True
SLO_CPU_LATENCY_CORRELATION: float = 0.7
SLO_MEMORY_LATENCY_CORRELATION: float = 0.4
```
