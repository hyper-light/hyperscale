---
ad_number: 18
name: Hybrid Overload Detection (Delta + Absolute)
description: Use delta-based detection with absolute safety bounds for overload detection
---

# AD-18: Hybrid Overload Detection (Delta + Absolute)

**Decision**: Use delta-based detection with absolute safety bounds for overload detection.

**Rationale**:
- Fixed thresholds cause flapping and require per-workload tuning
- Delta-based detection (rate of change) is self-calibrating
- Pure delta misses absolute capacity limits and suffers baseline drift
- Hybrid approach combines benefits of both

**Detection Model**:
```
┌─────────────────────────────────────────────────────────────────┐
│                    Hybrid Overload Detection                    │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Primary: Delta-based (% above EMA baseline + trend slope)     │
│  ├─ Tracks latency/queue depth relative to baseline            │
│  ├─ Uses Exponential Moving Average for baseline               │
│  ├─ Calculates trend via linear regression on delta history    │
│  └─ Self-calibrates to workload characteristics                │
│                                                                 │
│  Secondary: Absolute safety bounds (hard limits)               │
│  ├─ Prevents baseline drift masking real problems              │
│  ├─ Catches "stable but maxed out" scenarios                   │
│  └─ Example: latency > 5000ms = overloaded regardless          │
│                                                                 │
│  Tertiary: Resource signals (CPU, memory, queue depth)         │
│  ├─ Provides capacity awareness                                │
│  └─ Catches "about to fail" before latency spikes              │
│                                                                 │
│  Final State = max(delta_state, absolute_state, resource_state)│
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**State Levels**:
| State | Delta Threshold | Absolute Bound | Action |
|-------|-----------------|----------------|--------|
| healthy | < 20% above baseline | < 200ms | Normal operation |
| busy | 20-50% above baseline | 200-500ms | Reduce new work |
| stressed | 50-100% above baseline | 500-2000ms | Shed low-priority |
| overloaded | > 100% above baseline OR rising trend | > 2000ms | Emergency shed |

**Implementation**:
```python
@dataclass
class OverloadConfig:
    """Configuration for hybrid overload detection."""
    # Delta detection
    ema_alpha: float = 0.1  # Smoothing factor for baseline
    current_window: int = 10  # Samples for current average
    trend_window: int = 20  # Samples for trend calculation
    delta_thresholds: tuple[float, float, float] = (0.2, 0.5, 1.0)  # busy/stressed/overloaded

    # Absolute bounds (safety rails)
    absolute_bounds: tuple[float, float, float] = (200.0, 500.0, 2000.0)

    # Resource signals
    cpu_thresholds: tuple[float, float, float] = (0.7, 0.85, 0.95)
    memory_thresholds: tuple[float, float, float] = (0.7, 0.85, 0.95)

class HybridOverloadDetector:
    """Combines delta-based and absolute detection."""

    def __init__(self, config: OverloadConfig | None = None):
        self._config = config or OverloadConfig()
        self._baseline_ema: float = 0.0
        self._recent: deque[float] = deque(maxlen=self._config.current_window)
        self._delta_history: deque[float] = deque(maxlen=self._config.trend_window)

    def record_latency(self, latency_ms: float) -> None:
        """Record a latency sample and update state."""
        # Update baseline EMA
        if self._baseline_ema == 0.0:
            self._baseline_ema = latency_ms
        else:
            alpha = self._config.ema_alpha
            self._baseline_ema = alpha * latency_ms + (1 - alpha) * self._baseline_ema

        self._recent.append(latency_ms)

        # Calculate delta (% above baseline)
        if self._baseline_ema > 0:
            current_avg = sum(self._recent) / len(self._recent)
            delta = (current_avg - self._baseline_ema) / self._baseline_ema
            self._delta_history.append(delta)

    def get_state(self, cpu_percent: float = 0.0, memory_percent: float = 0.0) -> str:
        """Get current overload state using hybrid detection."""
        states = []

        # Delta-based state
        if len(self._recent) >= 3:
            current_avg = sum(self._recent) / len(self._recent)
            delta = (current_avg - self._baseline_ema) / max(self._baseline_ema, 1.0)
            trend = self._calculate_trend()

            if delta > self._config.delta_thresholds[2] or trend > 0.1:
                states.append("overloaded")
            elif delta > self._config.delta_thresholds[1]:
                states.append("stressed")
            elif delta > self._config.delta_thresholds[0]:
                states.append("busy")
            else:
                states.append("healthy")

        # Absolute bound state
        if self._recent:
            current_avg = sum(self._recent) / len(self._recent)
            if current_avg > self._config.absolute_bounds[2]:
                states.append("overloaded")
            elif current_avg > self._config.absolute_bounds[1]:
                states.append("stressed")
            elif current_avg > self._config.absolute_bounds[0]:
                states.append("busy")

        # Resource state
        cpu = cpu_percent / 100.0
        if cpu > self._config.cpu_thresholds[2]:
            states.append("overloaded")
        elif cpu > self._config.cpu_thresholds[1]:
            states.append("stressed")
        elif cpu > self._config.cpu_thresholds[0]:
            states.append("busy")

        # Return worst state
        state_order = {"healthy": 0, "busy": 1, "stressed": 2, "overloaded": 3}
        return max(states, key=lambda s: state_order.get(s, 0)) if states else "healthy"
```

**Advantages**:
- Self-calibrating: adapts to workload characteristics
- Less configuration: works across different deployments
- Catches both gradual degradation AND absolute limits
- Trend detection provides early warning

**Disadvantages**:
- Warm-up period required (mitigated by absolute bounds)
- More complex than simple thresholds
- Baseline drift possible over long periods (mitigated by absolute bounds)
