---
ad_number: 40
name: Idempotent Job Submissions
description: At-most-once job execution through client-generated idempotency keys with gate and manager caching.
---

# AD-40: Idempotent Job Submissions

## Part 1: Problem Statement and Requirements

### The Duplicate Submission Problem

In distributed systems, clients cannot distinguish between:
1. **Request lost** - Network dropped the request before gate received it
2. **Response lost** - Gate processed it but response didn't reach client
3. **Timeout** - Request is still being processed, just slow

Without idempotency, client retries cause duplicate job executions:

```
WITHOUT IDEMPOTENCY:
  Client submits job_id=abc --> Gate creates job abc
  Response lost
  Client retries with job_id=def --> Gate creates job def
  RESULT: TWO JOBS CREATED (abc AND def) FOR SAME LOGICAL REQUEST

WITH IDEMPOTENCY:
  Client submits idem_key=xyz, job_id=abc --> Gate creates job abc, stores idem_key->abc
  Response lost
  Client retries with idem_key=xyz, job_id=def --> Gate finds idem_key=xyz->abc
  RESULT: ONE JOB (abc), DUPLICATE DETECTED AND DEDUPLICATED
```

### Requirements

1. **At-Most-Once Semantics**: A job submission with a given idempotency key executes at most once
2. **Bounded Memory**: Idempotency state must not grow unboundedly
3. **Crash Recovery**: Idempotency guarantees survive gate/manager restarts
4. **Cross-DC Consistency**: Same idempotency key handled consistently across DCs
5. **Low Latency**: Dedup check must be O(1) and not add significant latency
6. **Configurable Window**: TTL for idempotency keys should be configurable

---

## Part 2: Idempotency Key Design

### Key Structure

The idempotency key uniquely identifies a logical submission attempt:

```python
@dataclass(slots=True, frozen=True)
class IdempotencyKey:
    """
    Client-generated idempotency key for job submissions.

    Structure: {client_id}:{sequence}:{nonce}

    - client_id: Stable identifier for the client (survives restarts)
    - sequence: Monotonically increasing counter per client
    - nonce: Random component to prevent collision across client restarts

    The combination ensures:
    - Same client retry uses same key (client_id + sequence)
    - Different clients cannot collide (different client_id)
    - Client restart doesn't reuse old sequences (nonce changes)
    """
    client_id: str      # Stable client identifier
    sequence: int       # Monotonically increasing per-client
    nonce: str          # Random component (8 bytes hex)
```

### Why This Structure?

| Component | Purpose | Example |
|-----------|---------|---------|
| client_id | Namespace isolation - Different clients never collide | "host1.dc1:12345" |
| sequence | Retry detection - Same seq = retry, New seq = new request | 42 |
| nonce | Restart protection - Prevents reuse of old sequence numbers | "a1b2c3d4e5f6g7h8" |

**Collision Analysis**:
- Same client, same request (retry): Same key, deduped
- Same client, different request: Different sequence
- Same client after restart: New nonce
- Different clients: Different client_id

---

## Part 3: Entry States and Lifecycle

### Idempotency Entry State Machine

```python
class IdempotencyStatus(Enum):
    """
    Status of an idempotency entry.

    State transitions:
        PENDING -> COMMITTED (successful processing)
        PENDING -> REJECTED (validation/capacity rejection)
        PENDING -> EXPIRED (TTL exceeded while pending)

    Terminal states (COMMITTED, REJECTED) are immutable.
    """
    PENDING = auto()    # Request received, processing in progress
    COMMITTED = auto()  # Request processed successfully
    REJECTED = auto()   # Request rejected (validation, capacity, etc.)
```

### State Transition Diagram

```
                        +----------------+
                        |                |
    new request         |   (not found)  |
         |              |                |
         v              +-------+--------+
  +--------------+              |
  |              |<-------------+
  |   PENDING    |
  |              |------+---------------+---------------+
  +--------------+      |               |               |
                        |               |               |
              success   |     reject    |     timeout   |
                        |               |               |
                        v               v               v
              +--------------+ +--------------+ +--------------+
              |              | |              | |              |
              |  COMMITTED   | |   REJECTED   | |   EXPIRED    |
              |              | |              | |   (removed)  |
              +------+-------+ +------+-------+ +--------------+
                     |                |
                     |   TTL          |   TTL
                     |   expires      |   expires
                     v                v
              +------------------------------+
              |                              |
              |     EVICTED (removed)        |
              |                              |
              +------------------------------+
```

### Duplicate Handling by State

| State | Action on duplicate |
|-------|---------------------|
| PENDING | Wait for original to complete (or timeout) |
| COMMITTED | Return cached result immediately |
| REJECTED | Return cached rejection immediately |
| (not found) | Insert PENDING, process as new request |

---

## Part 4: Gate-Level Idempotency Cache

The gate provides fast-path deduplication for client retries:

```python
class GateIdempotencyCache(Generic[T]):
    """
    Gate-level idempotency cache for fast-path duplicate detection.

    Design principles:
    - O(1) lookup and insertion
    - LRU eviction when at capacity
    - TTL-based expiration for all entries
    - Waiters for PENDING entries (coalesce duplicate requests)

    This is the first line of defense against duplicates. The manager
    provides authoritative deduplication for cross-gate scenarios.
    """
```

**Configuration**:

```python
@dataclass(slots=True, frozen=True)
class IdempotencyConfig:
    # TTL for entries in different states
    pending_ttl_seconds: float = 60.0       # How long to wait for pending
    committed_ttl_seconds: float = 300.0    # How long to cache committed (5 min)
    rejected_ttl_seconds: float = 60.0      # How long to cache rejections

    # Cache size limits
    max_entries: int = 100_000              # Maximum entries in cache

    # Cleanup interval
    cleanup_interval_seconds: float = 10.0  # How often to run cleanup

    # Behavior settings
    wait_for_pending: bool = True           # Wait for PENDING entries
    pending_wait_timeout: float = 30.0      # Max wait time for pending
```

---

## Part 5: Manager-Level Idempotency Ledger

The manager provides authoritative deduplication that survives restarts:

```python
class ManagerIdempotencyLedger(Generic[T]):
    """
    Manager-level idempotency ledger with WAL persistence.

    This is the authoritative source for idempotency decisions.
    Entries are persisted to WAL before acknowledging to ensure
    crash recovery maintains idempotency guarantees.

    Design:
    - In-memory index for O(1) lookups
    - WAL persistence for crash recovery
    - TTL-based cleanup to bound memory
    - Integration with per-job VSR for cross-DC consistency
    """
```

**Key Operations**:

1. **check_or_reserve**: Check if key exists; if not, reserve as PENDING (persisted to WAL)
2. **commit**: Transition from PENDING to COMMITTED with result
3. **reject**: Transition from PENDING to REJECTED with result

---

## Part 6: Integration Flow

```
Client --> Gate (check GateIdempotencyCache)
              |
              +-- Cache HIT (COMMITTED) --> Return cached result
              |
              +-- Cache HIT (PENDING) --> Wait for completion
              |
              +-- Cache MISS --> Insert PENDING, forward to Manager
                                      |
                                      v
                             Manager (check ManagerIdempotencyLedger)
                                      |
                                      +-- Ledger HIT --> Return cached result
                                      |
                                      +-- Ledger MISS --> Reserve in WAL, process job
                                                               |
                                                               v
                                                          Commit/Reject
                                                               |
                                                               v
                                                     Update Gate cache
```

---

## Part 7: Cross-DC Considerations

When a job submission targets multiple DCs:
1. Each DC's manager maintains independent idempotency state
2. The idempotency key ensures the same logical submission is deduplicated
3. Cross-DC coordination via global job ledger (AD-38) provides eventual consistency

---

## Part 8: Environment Configuration

```python
# Idempotency Settings (AD-40)
IDEMPOTENCY_PENDING_TTL_SECONDS: float = 60.0
IDEMPOTENCY_COMMITTED_TTL_SECONDS: float = 300.0
IDEMPOTENCY_REJECTED_TTL_SECONDS: float = 60.0
IDEMPOTENCY_MAX_ENTRIES: int = 100_000
IDEMPOTENCY_CLEANUP_INTERVAL_SECONDS: float = 10.0
IDEMPOTENCY_WAIT_FOR_PENDING: bool = True
IDEMPOTENCY_PENDING_WAIT_TIMEOUT: float = 30.0
```
