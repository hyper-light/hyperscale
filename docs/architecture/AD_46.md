---
ad_number: 46
name: SWIM Node State Storage via IncarnationTracker
description: Authoritative node membership state stored in IncarnationTracker with NodeState, not queues
---

# AD-46: SWIM Node State Storage via IncarnationTracker

**Decision**: SWIM node membership state is stored exclusively in `IncarnationTracker.node_states` using `NodeState` dataclass instances. The legacy `nodes` queue dict pattern is removed.

**Rationale**:
- SWIM membership is **state**, not events - queues are the wrong abstraction
- `NodeState` provides proper conflict resolution (incarnation wins, status priority)
- Queues grow unbounded under high update volume - `NodeState` is O(1) per node
- `IncarnationTracker` is already the authoritative source per AD-29

---

## Part 1: Problem - Legacy Queue Pattern

The original implementation used queues for node state:

```python
# env.py - INCORRECT legacy pattern
"nodes": defaultdict(asyncio.Queue)  # Unbounded queues per node
```

**Problems with queue-based approach**:

| Issue | Impact |
|-------|--------|
| Unbounded growth | Millions of updates/sec causes OOM |
| Wrong semantics | Queues are for events, not latest-state |
| No conflict resolution | No incarnation/status priority handling |
| Redundant storage | Duplicates IncarnationTracker state |
| Dead code | `QueueFull` handling never triggers on unbounded queues |

---

## Part 2: Solution - IncarnationTracker as Single Source of Truth

### NodeState Dataclass

```python
@dataclass(slots=True)
class NodeState:
    """Tracks state of a known node in SWIM membership."""
    status: Status = b'OK'           # OK, SUSPECT, DEAD, UNCONFIRMED
    incarnation: int = 0             # Monotonic version for conflict resolution
    last_update_time: float = 0.0    # For staleness detection

    def update(self, new_status: Status, new_incarnation: int, timestamp: float) -> bool:
        """
        Update if new information is fresher.
        
        Resolution rules (per SWIM + AD-35):
        - Higher incarnation always wins
        - Same incarnation: DEAD > SUSPECT > OK > UNCONFIRMED
        - Lower incarnation always ignored
        """
```

### IncarnationTracker

```python
@dataclass
class IncarnationTracker:
    """Single source of truth for SWIM node membership state."""
    
    node_states: dict[tuple[str, int], NodeState]  # (host, port) -> NodeState
    
    # Resource limits (AD-29)
    max_nodes: int = 10000
    dead_node_retention_seconds: float = 3600.0
    
    def update_node(self, node, status, incarnation, timestamp) -> bool:
        """Atomic state update with conflict resolution."""
    
    def get_node_state(self, node) -> NodeState | None:
        """O(1) lookup of current state."""
    
    async def cleanup(self) -> dict[str, int]:
        """Evict stale/dead nodes to bound memory."""
```

---

## Part 3: Why This Scales to Millions of Updates/Second

### Memory Efficiency

| Approach | Memory per node | Memory for 1M updates to same node |
|----------|-----------------|-----------------------------------|
| Queue | O(updates) | ~100MB (1M queued tuples) |
| NodeState | O(1) | ~64 bytes (single NodeState) |

### Performance Characteristics

```
NodeState.update():
- dict lookup: O(1) average
- field assignments: O(1)
- no allocations in hot path (slots)
- no await points (atomicity in asyncio)

Total: O(1) per update, zero GC pressure
```

### Asyncio Safety

`IncarnationTracker` methods are **synchronous with no await points**. In asyncio's single-threaded model, this means:
- No interleaving between check and update
- No locks needed
- Naturally atomic operations

```python
def update_node(self, node, status, incarnation, timestamp) -> bool:
    # All of this runs without yielding to event loop
    if node not in self.node_states:        # sync dict lookup
        self.node_states[node] = NodeState(...)  # sync insert
        return True
    return self.node_states[node].update(...)    # sync update
```

---

## Part 4: Migration from Legacy Queue Pattern

### Before (Incorrect)

```python
# env.py
def get_swim_init_context(self) -> dict:
    return {
        "nodes": defaultdict(asyncio.Queue),  # WRONG
        ...
    }

# message handlers
await self._server.safe_queue_put(nodes[target], (timestamp, status), target)

# status checks
_, status = nodes[target].get_nowait()
```

### After (Correct)

```python
# env.py - remove "nodes" from context entirely
def get_swim_init_context(self) -> dict:
    return {
        # "nodes" removed - use incarnation_tracker instead
        ...
    }

# message handlers
self._server.incarnation_tracker.update_node(
    target, status, incarnation, time.monotonic()
)

# status checks  
state = self._server.incarnation_tracker.get_node_state(target)
if state:
    status = state.status
```

---

## Part 5: Integration with Other ADs

| AD | Relationship |
|----|--------------|
| AD-29 | IncarnationTracker provides confirmed/unconfirmed peer model |
| AD-30 | Hierarchical failure detection reads from IncarnationTracker |
| AD-33 | Federated health uses IncarnationTracker for DC manager state |
| AD-35 | Status priority rules implemented in NodeState.update() |

---

## Part 6: Files Modified

| File | Change |
|------|--------|
| `hyperscale/distributed/env/env.py` | Remove `nodes` from `get_swim_init_context()` |
| `hyperscale/distributed/swim/health_aware_server.py` | Remove `safe_queue_put`, use `incarnation_tracker` |
| `hyperscale/distributed/swim/message_handling/membership/*.py` | Update handlers to use `incarnation_tracker` |
| `hyperscale/distributed/swim/core/types.py` | Remove `Nodes` type alias |

---

## Part 7: Anti-Patterns to Avoid

**DO NOT**:
```python
# Use queues for membership state
nodes[addr] = asyncio.Queue()
await queue.put((timestamp, status))

# Create separate state tracking
_node_status_cache: dict[addr, Status]  # Duplicates IncarnationTracker

# Use defaultdict with Queue factory
defaultdict(asyncio.Queue)  # Unbounded, wrong semantics
```

**DO**:
```python
# Use IncarnationTracker exclusively
self._incarnation_tracker.update_node(node, status, incarnation, timestamp)
state = self._incarnation_tracker.get_node_state(node)
```

---

## Part 8: Testing Strategy

1. **Unit tests**: Verify `NodeState.update()` conflict resolution
2. **Scale tests**: 1M updates/sec to same node, measure memory
3. **Integration tests**: SWIM protocol with IncarnationTracker
4. **Regression tests**: Ensure no queue-based patterns reintroduced
