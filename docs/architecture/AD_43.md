---
ad_number: 43
name: Capacity-Aware Spillover and Core Reservation
description: Workflow duration tracking with estimated wait time calculation for proactive cross-DC spillover routing.
---

# AD-43: Capacity-Aware Spillover and Core Reservation

## Part 1: Problem Statement

**Current Limitation**: Gates route jobs based on datacenter health classification (HEALTHY/BUSY/DEGRADED/UNHEALTHY) but lack visibility into actual core capacity. This creates suboptimal routing:

1. **No Capacity Planning**: Gates don't know "DC-A has 500 total cores, 200 available"
2. **No Wait Time Estimation**: When a DC is BUSY, gates can't estimate when capacity will free
3. **First-Come-First-Serve Only**: Jobs queue at the primary DC even when a nearby DC has immediate capacity
4. **No Proactive Spillover**: Jobs wait in queue instead of spilling to DCs with available cores

**Example Problem**:
```
Job X requires 100 cores
DC-A (primary): 50 available, queue depth 20, ~5 min until cores free
DC-B (nearby):  200 available, queue depth 0

Current behavior: Job X queues at DC-A, waits 5+ minutes
Desired behavior: Job X spills to DC-B, starts immediately
```

---

## Part 2: Execution Model

### Worker Level
- Exactly 1 workflow per core (strict 1:1 mapping)
- NO queue at worker level
- Reports `available_cores` to manager
- Rejects dispatch if no cores available

### Manager Level
- Tracks active dispatches with durations
- Maintains pending queue with declared workflow durations
- Calculates estimated time until cores free
- Reports capacity metrics to gates

### Gate Level
- Aggregates manager heartbeats into DC-wide capacity
- Makes spillover decisions based on capacity + wait time
- Routes jobs to DC with best capacity/latency tradeoff

---

## Part 3: Workflow Duration Source

Workflows declare their expected duration as a class attribute:

```python
class Workflow:
    vus: int = 1000
    duration: str = "1m"   # Expected execution duration
    timeout: str = "30s"   # Additional timeout buffer
```

**Key Insight**: Since workflows declare duration upfront, managers can calculate:
1. Remaining time for active dispatches: `duration - (now - dispatched_at)`
2. Total pending queue duration: `sum(pending_workflow.duration)`
3. Estimated time until N cores free up

---

## Part 4: Manager Execution Time Estimation

### Active Dispatch Tracking

```python
@dataclass(slots=True)
class ActiveDispatch:
    workflow_id: str
    job_id: str
    worker_id: str
    cores_allocated: int
    dispatched_at: float      # time.monotonic() when dispatched
    duration_seconds: float   # From Workflow.duration (parsed)
    timeout_seconds: float    # From Workflow.timeout (parsed)
```

### Wait Time Calculation Algorithm

1. Get completion times for all active dispatches
2. Sort by expected completion
3. Simulate cores freeing up
4. Return time when enough cores available

---

## Part 5: Extended ManagerHeartbeat

```python
@dataclass(slots=True)
class ManagerHeartbeat(Message):
    # ... existing fields ...

    # AD-43: Capacity estimation fields
    pending_workflow_count: int = 0
    pending_duration_seconds: float = 0.0
    active_remaining_seconds: float = 0.0
    estimated_cores_free_at: float = 0.0
    estimated_cores_freeing: int = 0
    cores_freeing_schedule: bytes = b""  # Serialized list[(time_offset, cores)]
```

---

## Part 6: Gate Capacity Aggregation

```python
@dataclass(slots=True)
class DatacenterCapacity:
    datacenter_id: str
    total_cores: int
    available_cores: int
    pending_workflow_count: int
    pending_duration_seconds: float
    active_remaining_seconds: float
    estimated_wait_seconds: float
    utilization: float
    health_bucket: str
    last_updated: float
```

---

## Part 7: Spillover Decision Logic

### Spillover Triggers

1. Primary DC cannot serve immediately (`available_cores < required`)
2. Primary DC wait time exceeds threshold
3. A nearby DC has immediate capacity
4. Latency penalty is acceptable

### SpilloverEvaluator

```python
@dataclass(slots=True)
class SpilloverDecision:
    should_spillover: bool
    reason: str
    primary_dc: str
    spillover_dc: str | None
    primary_wait_seconds: float
    spillover_wait_seconds: float
    latency_penalty_ms: float
```

### Decision Flow

1. Check if primary can serve immediately -> No spillover
2. Calculate primary wait time
3. If wait acceptable -> No spillover
4. Find best spillover candidate with immediate capacity
5. Verify latency penalty is acceptable
6. Return spillover recommendation

---

## Part 8: Environment Configuration

```python
# Capacity-Aware Spillover Settings (AD-43)
SPILLOVER_ENABLED: bool = True
SPILLOVER_MAX_WAIT_SECONDS: float = 60.0
SPILLOVER_MAX_LATENCY_PENALTY_MS: float = 100.0
SPILLOVER_MIN_IMPROVEMENT_RATIO: float = 0.5
CAPACITY_HEARTBEAT_INTERVAL_SECONDS: float = 5.0
```
